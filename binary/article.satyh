@require: itemize
@require: code

@require: class-yabaitech/yabaitech

@import: lib

module Binary : sig

  val article : block-text

end = struct

  open BinaryCommands

  let-inline \dfn-ja-en ja en = {\dfn{#ja; (#en;)}}

  let article = '<
    +chapter(|
      bibliography = [];
      title = {テキサスホールデムの役判定に見る高速化テクニック};
      title-for-toc = Option.none;
      subtitle = Option.none;
      author = {ばいなり};
    |)
    <
      +section{はじめに} <
        +p{
          はじめまして、 yabaitech.tokyo の新メンバーのばいなりです。
          yabaitech.tokyo のメンバーの一部でテキサスホールデムポーカーが流行っており、
          一緒にポーカーで遊んでいたらこちらに加入させられてしまいました。
          せっかくなのでポーカーに関する技術記事を書こうということで、
          今回はテキサスホールデムの役判定を爆速で行う話についてでも書かせてもらえればと思います。
        }

        +p{
          所詮はポーカーの役判定ごとき、もともと愚直に書いてもマイクロ秒単位で処理できるため、
          もともと高速じゃないか、そんなものを高速化して何が面白いのかと思われるかもしれませんが、
          次章で説明するようにテキサスホールデムポーカーでは使えるカードが
          明らかになっていない段階でアクションを起こす必要があり、
          その時点での勝率を計算しようとすると大量にあり得るハンドの役判定を行わねばならず、
          この処理の高速化が要求されるわけです。
          最終的には処理時間が\dfn{約1ナノ秒}のプログラムまで紹介しますので、
          楽しみに読み進めていただけれると幸いです。
        }
      >

      +section{テキサスホールデムのルール} <
        +p{
          \dfn-ja-en{テキサスホールデム}{Texas hold'em} は、数あるポーカーの変種の中でも
          世界的に見て最もポピュラーなものと言えるゲームです。
          日本ではまだ馴染みの薄い感じもありますが、世界的には数多くのプレイヤーがおり、
          最も権威ある世界大会ではなんと10,000,000ドル (!) もの優勝賞金が懸けられるほどです。
          この章では、テキサスホールデムとは何ぞやという方に向けて、そのルールを簡単に説明します
          （テキサスホールデムを既に知っている方は読み飛ばしていただいても構いません）。
        }

        +subsection?:(`list-of-poker-hands`){役の一覧} <
          +p{
            テキサスホールデムにおける役は5枚のカードの組み合わせで決まり、
            強い順に以下の9つがあります。
            さまざまなポーカーの変種で共通なため、馴染みのある方も多いでしょう。
          }

          +enumerate{
            * \dfn-ja-en{ストレートフラッシュ}{Straight flush}:
              フラッシュとストレートの複合役。すべての役の中で最も強い。
              例: \spade{A} \spade{K} \spade{Q} \spade{J} \spade{10}
            * \dfn-ja-en{フォーカード}{Four of a kind}:
              同じランク（数字）のカードを4枚集めた役。
              例: \spade{6} \heart{6} \diamond{6} \club{6} \diamond{J}
            * \dfn-ja-en{フルハウス}{Full house}:
              同じランクのカード3枚と、別の同じランクのカード2枚で構成される役。
              例: \heart{K} \diamond{K} \club{K} \heart{3} \club{3}
            * \dfn-ja-en{フラッシュ}{Flush}:
              同じスート（柄）のカードを5枚集めた役。
              例: \heart{Q} \heart{10} \heart{7} \heart{5} \heart{4}
            * \dfn-ja-en{ストレート}{Straight}:
              数字が連続した5枚のカードで構成される役。
              Aは14または1として扱うことができる。
              A、K、2の3枚を含むものはストレートとは見なされない。
              例: \heart{J} \club{10} \club{9} \heart{8} \spade{7}
            * \dfn-ja-en{スリーカード}{Three of a kind}:
              同じランクのカードを3枚集めた役。
              例: \spade{5} \diamond{5} \club{5} \heart{A} \club{J}
            * \dfn-ja-en{ツーペア}{Two pair}:
              同じランクのカード2枚の組を2組集めた役。
              例: \spade{8} \club{8} \spade{3} \diamond{3} \diamond{Q}
            * \dfn-ja-en{ワンペア}{One pair}:
              同じランクのカードを2枚集めた役。
              例: \diamond{7} \club{7} \spade{9} \spade{4} \diamond{2}
            * \dfn-ja-en{ハイカード}{High card}:
              上記のいずれにも当てはまらないもの。いわゆる“ブタ”。
              例: \club{A} \spade{J} \diamond{8} \club{4} \heart{2}
          }

          +p{
            役が同じ場合は、カードのランクをもとにタイブレークがなされます
            （Aが最も強く、2が最も弱い\; ストレートでAを1として扱った場合のみAが最も弱い）。
            カードのスートはハンドの強さに影響しません。
            このようにハンドの強さを定義した場合、
            ハンドは7462種の同値類に分類されることが知られています。
          }
        >

        +subsection{テキサスホールデムの進行} <
          +p{
            テキサスホールデムでは、\dfn-ja-en{ホールカード}{Hole cards}と呼ばれる
            各プレイヤーに2枚ずつ配られるカードと、\dfn-ja-en{コミュニティカード}{Community cards}
            と呼ばれるプレイヤー全員が使用できる5枚の共通のカードの計7枚の中から、
            最も強い5枚の組み合わせを用いてハンドの強さを競います。
            よくあるクローズドポーカーとは異なり、配られた手札を交換することはできません。
            最終的に手札を公開してハンドの強さを競うことになった場合
            （これを\dfn-ja-en{ショーダウン}{Showdown}と呼ぶ）、
            より強いハンドを持っていたプレイヤーが
            それまでに賭けられてきた\dfn-ja-en{ポット}{Pot}を総取りします。
          }

          +p{
            ただし、実際の進行ではショーダウンが行われることはそれほどありません。
            というのも、他のプレイヤーを全員“降ろす”ことができれば、
            その時点でポットは残った1人のプレイヤーのものとなるためです。
            ベッティングラウンドでは、賭け金の合意が取れるまで各プレイヤーは定められた順序で
            以下のいずれかのアクションを取る必要があります:
          }

          +listing{
            * \dfn-ja-en{ベット}{Bet} / \dfn-ja-en{レイズ}{Raise}:
              現在の賭け金からさらに賭け金を上乗せするアクションです。
              賭け金がゼロの状態から行うアクションをベット、
              既にベットされている状態から行うアクションをレイズと言います。
            * \dfn-ja-en{チェック}{Check} / \dfn-ja-en{コール}{Call}:
              現在の賭け金に同意し、同額を支払ってプレイを継続するアクションです。
              追加の賭け金が必要無い状態で行うアクションをチェック、
              賭け金を追加で支払う必要のある状態で行うアクションをコールと言います。
            * \dfn-ja-en{フォールド}{Fold}:
              現在の賭け金を支払わず、手札を捨てて勝負から降りるアクションです。
              フォールドを行うと、それ以降のベッティングラウンドにも参加できず、
              ポットを獲得する権利を完全に失います。
          }

          +p{
            テキサスホールデムでは、ショーダウンまでに4回のベッティングラウンドを行います:
          }

          +listing{
            * \dfn-ja-en{プリフロップ}{Pre-flop}:
              2枚のホールカードが配られた直後に行われるラウンドです。
              コミュニティカードは1枚も公開されません。
              プリフロップでは、\dfn-ja-en{スモールブラインド}{Small blind}と
              \dfn-ja-en{ビッグブラインド}{Big blind}と呼ばれる2人のプレイヤーは
              定められた額のベットを強制的に行わなければなりません。
            * \dfn-ja-en{フロップ}{Flop}:
              コミュニティカードが3枚公開された状態で行われるラウンドです。
            * \dfn-ja-en{ターン}{Turn}:
              4枚目のコミュニティカードが公開された状態で行われるラウンドです。
            * \dfn-ja-en{リバー}{River}:
              5枚目のコミュニティカードが公開され、すべてのコミュニティカードが
              明らかになった状態で行われるラウンドです。
          }

          +p{
            特にプリフロップの段階では、最終的に使用できる7枚のカードのうち2枚しか
            明らかになっていません。この時点での勝率の計算などを厳密に行おうとすると、
            大量にあり得るハンドの役判定が必要になるという冒頭の主張に繋がるわけです。
          }
        >
      >

      +section{レギュレーション} <
        +p{
          さて、以上に説明したテキサスホールデムのルールを踏まえて、
          作りたいプログラムの要件を定義していきましょう。
          今回の目標は「7枚のカードの組が与えられたときの役の判定」を行うプログラムであって、
          なるべく高速なものを作ることです。
          もう少し厳密に書くと、次の要件を満たすようななるべく高速な関数の実装を目指します。
        }

        +listing{
          * 7枚のカードで構成されるハンドを入力として受け取って非負整数を返す関数であって、
            \ref-subsection(`list-of-poker-hands`); に示したようにハンドの強さを定義したとき、
            より強いハンドが入力として与えられた場合はより大きい整数を返し、
            強さが同じハンドが入力として与えられた場合は同じ整数を返すようなもの
            （特に、役が同じであっても多くの場合はタイブレークによる強弱が存在することに注意する）。
        }

        +p{
          なお、各カードは0～51の整数で表現されているものとし、
          0～3が\club{2} \diamond{2} \heart{2} \spade{2}、
          4～7が\club{3} \diamond{3} \heart{3} \spade{3}、${\cdots}、
          48～51が\club{A} \diamond{A} \heart{A} \spade{A}に対応しているものとします。
        }

        +p{
          今回は勝率計算などに用いるサブルーチンとしての役判定を想定しているため、
          プログラムの高速化のために次のような機能は含めなくてよいものとします:
        }

        +listing{
          * ハンドが7枚未満の場合の役判定を行う機能。
          * 7枚のカードのうちどの5枚が用いられたかを示す機能。
          * 入力のバリデーションチェック。すなわち、入力長は7であり、入力の各要素が
            0～51の整数であって相異なることを仮定する。
        }

        +p{
          プログラムは以下の3点によって評価されます:
        }

        +listing{
          * \dfn{シーケンシャル速度}:
            52 choose 7 (TODO: 数式にしたい)（＝133,784,560）通りの7枚のカードの組み合わせについて
            辞書順にハンドの評価を行い、掛かった時間を計測する。
            この測定では、ハンドを表現する何らかのデータ構造にカードを追加する操作は
            最内ループの外で行っても良いものとする。
            すなわち、以下のようなプログラムが認められる:

            \d-code(```
              Hand hand = Hand();
              for (int card1 = 0; card1 < 46; ++card1) {
                // add_card()の複雑さに関わらず、この操作を以降のループ中に含めなくてよい
                Hand hand1 = hand.add_card(card1);  // handにcard1を追加した結果を返す
                for (int card2 = card1 + 1; card2 < 47; ++card2) {
                  Hand hand2 = hand1.add_card(card2);
                  // 3枚目以降のカードの処理...
                }
              }
            ```);

          * \dfn{ランダムアクセス速度}:
            1億通りのランダムなハンドについて評価を行い、掛かった時間を計測する。
            この測定では、0～51の整数からなる要素数7のランダムな配列のみが予め用意される。
            なお、配列の要素はソートされているとは限らない。
            ハンドを表現する何らかのデータ構造にカードを追加する操作が必要な場合は
            毎回ゼロから行う必要があり、その時間も計測結果に反映される。

          * \dfn{メモリ使用量}:
            これから紹介するプログラムには、予め前計算したテーブルを用いるものが含まれるため、
            そういった静的なテーブルの大きさを示す（実行時のメモリ使用量を計測したものではない）。
            静的なテーブルを用いない場合は「極小」と表記する。
        }

        +p{
          プログラムの記述言語にはC++17を採用します。
          また、実行時間の計測には筆者のデスクトップマシン（Ryzen 7 3700X CPU）を用います。
        }

        +p{
          それでは、次章でさまざまな実装について見ていきましょう！
        }
      >

      +section{さまざまな実装} <
        +subsection?:(`evaluator-naive`){ナイーブな実装} <
          +listing{
            * \dfn{シーケンシャル速度}（1.33億ハンド）: 64.8秒（206万評価/秒）
            * \dfn{ランダムアクセス速度}（1億ハンド）: 52.4秒（191万評価/秒）
            * \dfn{メモリ使用量}: 極小
          }

          +p{
            何はともあれ、まずはベースラインとなるナイーブな実装について見ていきましょう。
            7枚のカードから5枚を選ぶ21通りの選び方を予め定数として用意しておき、
            その組み合わせをすべて試して最も強かった結果を返すというのが
            ナイーブな実装の大枠になるかと思います。
          }

          +p{
            5枚のカードからなるハンドの評価を行う関数 `evaluate_hand_naive_5()`については
            後ほど見ていくことにして、プログラムを記述していくと次のようになるでしょう:

            \d-code(```
              // 7 choose 5の組み合わせを予め定数として持っておく
              const int comb_7_5[21][5] = {
                { 0, 1, 2, 3, 4 }, { 0, 1, 2, 3, 5 }, (中略), { 2, 3, 4, 5, 6 }
              };

              // 7枚のカードからなるハンドの強さを評価する
              int evaluate_hand_naive(const vector<int> &hand) {
                int best = 0;
                vector<int> subhand(5);
                for (int i = 0; i < 21; ++i) {
                  for (int j = 0; j < 5; ++j) {
                    subhand[j] = hand[comb_7_5[i][j]];
                  }
                  best = max(best, evaluate_hand_naive_5(subhand));
                }
                return best;
              }
            ```);
          }

          +p{
            それでは、関数`int evaluate_hand_naive_5(const vector<int> &hand);`を続いて
            定義していきましょう。ナイーブとは言えども、ビット演算を利用した効率的な実装を
            目指すこととし、まずは出現したスートとランクを管理するビットセットと、
            各ランクの出現回数を管理する変数を準備します。

            \d-code(```
              int suitset = 0;
              int rankset = 0;
              int rankcount[13] = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };
              for (int card : hand) {
                int suit = card % 4;
                int rank = card / 4;
                suitset |= 1 << suit;
                rankset |= 1 << rank;
                ++rankcount[rank];
              }
            ```);

            さらに、出現回数からランクのビットセットを逆引きできる変数も準備します。

            \d-code(```
              int rankset_of_count[5] = { 0, 0, 0, 0, 0 };
              for (int rank = 0; rank < 13; ++rank) {
                rankset_of_count[rankcount[rank]] |= 1 << rank;
              }
            ```);

            以上の変数が用意できれば、フラッシュとストレートの判定は以下のように行えます。

            \d-code(```
              bool is_flush = count_ones(suitset) == 1;
              int is_straight = rankset & (rankset << 1) & (rankset << 2)
                              & (rankset << 3) & (rankset << 4);
              if (rankset == 0b1'0000'0000'1111) is_straight = 1 << 3;
            ```);

            ここで、`count_ones()`は2進数表記でのビットの立っている数を返す関数とします
            （gcc/clangにおける`__builtin_popcount()`と同様）。
            フラッシュの判定は明らかですが、ストレートの判定については解説が必要かもしれません。
            ストレートが成立している場合、ランクのビットセットは5桁連続でビットが立っている
            ことになります（5432Aの場合を除く）。このとき、ビットを0～4桁ズラしたもの同士で
            ビット論理積を取るとその結果は非ゼロとなります。

            \d-code(```
                0000000111110 (x)
              & 0000001111100 (x << 1)
              & 0000011111000 (x << 2)
              & 0000111110000 (x << 3)
              & 0001111100000 (x << 4)
              ------------------------
                0000000100000
            ```);

            逆に、ストレートが成立していない場合は、このビット論理積はゼロとなります。
            よって、唯一の例外である5432Aのストレートについて最後にケアしてあげれば、
            変数`is_straight`は非ストレートの場合はゼロ、またストレートの場合は非ゼロでかつ
            最もランクの大きいカードの情報が入っている状態となります。
          }

          +p{
            ここまで準備ができれば、あとはナイーブに役判定を行っていくのみです。
            ここで返り値のフォーマットについて考える必要がありますが、
            上位4ビットに役の情報を、下位26ビットにタイブレークに関する情報を埋め込んだ
            30ビットの整数を用いることにしましょう。

            \d-code(```
              if (is_flush && is_straight) {
                // straight flush
                return (8 << 26) | is_straight;
              } else if (rankset_of_count[4]) {
                // four of a kind
                return (7 << 26) | (rankset_of_count[4] << 13) | rankset_of_count[1];
              } else if (rankset_of_count[3] && rankset_of_count[2]) {
                // full house
                return (6 << 26) | (rankset_of_count[3] << 13) | rankset_of_count[2];
              } else if (is_flush) {
                // flush
                return (5 << 26) | rankset;
              } else if (is_straight) {
                // straight
                return (4 << 26) | is_straight;
              } else if (rankset_of_count[3]) {
                // three of a kind
                return (3 << 26) | (rankset_of_count[3] << 13) | rankset_of_count[1];
              } else if (rankset_of_count[2]) {
                // two pair or one pair
                int num_pairs = count_ones(rankset_of_count[2]);
                return (num_pairs << 26) | (rankset_of_count[2] << 13) | rankset_of_count[1];
              } else {
                // high card
                return (0 << 26) | rankset;
              }
            ```);
          }

          +p{
            以上がナイーブな実装についてでしたが、これだけで予想外に3ページ半も
            費やしてしまいました。タイブレークまで正確に考慮した実装を簡潔に記述するのは
            案外簡単ではないのではということで丁寧に解説してみましたが、いかがでしたでしょうか。
          }
        >

        +subsection?:(`evaluator-naive-7`){7枚のカードを直接評価する実装（ナイーブ）} <
          +listing{
            * \dfn{シーケンシャル速度}（1.33億ハンド）: 4.32秒（3100万評価/秒）
            * \dfn{ランダムアクセス速度}（1億ハンド）: 4.19秒（2390万評価/秒）
            * \dfn{メモリ使用量}: 極小
          }

          +p{
            \ref-subsection(`evaluator-naive`); で紹介したナイーブな実装は 7 choose 5 通りの
            カードの選び方をすべて試すものでしたが、7枚のカードが与えられたときにそれらを
            直接評価する戦略も考えられます。
            例えば、\club{K} \diamond{10} \club{8} \club{4} \heart{4} \spade{4} \heart{3}という
            ハンドが与えられたとき、人間は 7 choose 5 通りのカードの選び方を考えなくとも、
            まず4のスリーカードを認識し、残ったカードのうちランクの高い\club{K}と\diamond{10}を
            加えた\club{4} \heart{4} \spade{4} \club{K} \diamond{10}が最終的な5枚組になることを
            把握できるでしょう。
          }

          +p{
            このような戦略に基づく実装を正確に書き下すのは、5枚のハンドを評価する実装と比べてさらに
            注意力を要しますが、丁寧に考察をしていけばそれなりに簡潔に記述することが可能です。
            まずは、ユーティリティ関数として上位`n`ビットを保持する関数を定義しましょう:

            \d-code(```
              int keep_n_msb(int x, int n) {
                int result = 0;
                for (int i = 0; i < n; ++i) {
                  int m = msb(x);
                  x ^= m;
                  result |= m;
                }
                return result;
              }
            ```);

            ここで、 `msb(x)` は入力 `x` の最上位ビットのみが立った値を返す関数とします
            （gcc/clangでは `int` 型に対しては `1 << (__builtin_clz(x) ^ 31)` として定義できます）。
            このような関数を用意できると、先ほどの例のようなスリーカードの処理は次のように
            書き下すことができます:

            \d-code(```
              // スリーカードより強い役ではないことが確認できているとする
              if (rankset_of_count[3]) {
                // three of a kind
                int remaining = keep_n_msb(rankset_of_count[1], 2);
                return (3 << 26) | (rankset_of_count[3] << 13) | remaining;
              }
            ```);

            本節では実装のすべての紹介は行いませんが、この戦略に基づく実装を実際に書いてみようと
            いう場合は、ストレートとフラッシュが両方成立しているからといってストレートフラッシュとは
            限らない点（ストレートフラッシュは同じスート内でストレートを完成させる必要がある）、
            3枚組が2つある場合の処理（フルハウス）、2枚組が3つある場合の処理（ツーペア）などに
            気をつけてみてください。
          }

          +p{
            筆者の実装では、\ref-subsection(`evaluator-naive`); の実装と比べて
            12～15倍の高速化を実現することができました。
            どの5枚が最終的に用いられたかの情報を復元する処理は自明には書けなくなって
            しまいましたが、それと引き換えにこれだけの高速化が施せれば十分でしょう。
          }

          +p{
            このような記事を書いておいて言うのも微妙ですが、ポーカーの役判定が必要となるような
            場面のほとんどは、\ref-subsection(`evaluator-naive`); と本節に示したような
            ナイーブな処理で正直間に合うようにも思います。
            ここからさまざまなテクニックを用いて処理を高速化していくわけですが、
            最終的に得られるプログラムは本節のものと比べて25倍速いという程度に留まります。
            この25倍を引き出す過程が面白いと感じたからこそこのような記事を
            書いているわけではありますが、25倍遅い程度で済むなら明快な処理の方が好ましいという
            状況も少なくないのではないでしょうか。
            また、ナイーブな実装は高速な実装の動作をテストする際にも役に立ちますので、
            ナイーブなものが悪いということでは決してない点は留意していただければと思います。
          }
        >

        +subsection?:(`evaluator-hash-table`){前計算に基づく巨大なテーブルを用いる実装（その１）} <
          +listing{
            * \dfn{シーケンシャル速度}（1.33億ハンド）: 14.9秒（900万評価/秒）
            * \dfn{ランダムアクセス速度}（1億ハンド）: 58.8秒（170万評価/秒）
            * \dfn{メモリ使用量}: 約5.5GB
          }

          +p{
            52枚のカードのうち7枚を取り出す場合の数は、52 choose 7 = 133,784,560 通りです。
            これらの約1.33億通りの場合について予め前計算を行ってテーブルとして
            保存してしまうことを考えると、各要素を2バイト整数で表現した場合
            （前述したようにハンドの強さは7462種類の同値類に分類できるため2バイト整数で表現可能）、
            高々256MBの容量に収まることが分かります。
            この256MBという容量は、例えばアプリに組み込むことを考えるとこれだけですでに
            許容できない容量で、後述するようにハッシュテーブル等を用いてしまうとさらに定数倍が
            掛かってしまいますが、ローカルで計算を行う分には何とかなるでしょう。
            ここからは、このように予め約1.33億通りの場合をすべて前計算してしまって、
            その結果を利用することで高速化が図れないかを考えていきます。
          }

          +p{
            まず問題となるのは、0～51の整数で表現されたカード7枚の組が与えられたときに、
            どうやってテーブルを引くのかという点です。
            つまり、カード7枚の組を何かしらのフォーマットに正規化する方法を考える必要があります。
            ここでは、カードを表す整数7つをソートして順序を一意にした上で、
            それらを8ビット整数として並べた56ビット整数として表現することにしてみましょう。
            このようにフォーマットを定めてさえしまえば、あとは探索木なりハッシュテーブルなりで
            検索を行うことが可能になります。
            例えば、ハッシュテーブルを用いた実装は次のようになるでしょう:

            \d-code(```
              // ハッシュテーブルは前計算しておく
              unordered_map<uint64_t, uint16_t> hash_table;

              uint16_t evaluate_hand_hash_table(const vector<int> &hand) {
                int sorted[7];
                copy(hand.begin(), hand.end(), sorted);
                sort(sorted.begin(), sorted.end());
                uint64_t lo = sorted[0] | (sorted[1]<<8) | (sorted[2]<<16) | (sorted[3]<<24);
                uint64_t hi = sorted[4] | (sorted[5]<<8) | (sorted[6]<<16);
                return hash_table[lo | (hi << 32)];
              }
            ```);
          }

          +p {
            さてこれにて一件落着…としたいところなのですが、せっかく高速化の記事ですので
            この実装をさらに高速にすることを考えましょう。
            ここで注目するのは `sort()` を呼び出している部分です。
            C++ STL（標準ライブラリ）のソート関数は汎用的に使用できるものですが、
            今回は要素数が7であることが分かっているため、このことを利用します。
          }

          +p{
            小さい配列のソートのような処理においてボトルネックとなるのは、主に条件分岐です。
            CPUはヒューリスティクスによって条件分岐命令が実行される以前から分岐を予測し、
            投機的に命令を実行していますが、この予測が失敗した際にオーバーヘッドが生じます。
            小さい配列のソートにおいては、条件分岐が何回も行われる上にその予測も難しいため、
            このオーバーヘッドが問題になるわけです。
          }

          +p{
            そこで、ここでは\dfn{ソーティングネットワーク}を用いることにします。
            ソーティングネットワークに関する詳細な説明はWikipedia等に譲りますが、
            簡単に言えば2要素のソートを定められた順序で複数回繰り返すことで
            ソートを実現するという手法です。
            この“定められた順序で”というのが重要で、比較の順序がそれまでの比較結果によらないため、
            比較の順序に関する分岐を廃することが可能で、並列実行に向いたアルゴリズムでもあります。
          }

          +p{
            7要素のソートの場合は、2要素のソートを16回行うことでソートを行うことが可能で、
            また16回という回数が下限である（＝最適である）ことも知られています
            （ソーティングネットワークでない一般の比較ソートでは比較回数の下限は13回となりますが、
            こちらはそれまでの比較結果に応じて比較対象が動的に変化します）。

            \d-code(```
              void sort_7(int *p) {
                sort_2(p[0], p[4]); sort_2(p[1], p[5]); sort_2(p[2], p[6]);
                sort_2(p[0], p[2]); sort_2(p[1], p[3]); sort_2(p[4], p[6]);
                sort_2(p[2], p[4]); sort_2(p[3], p[5]);
                sort_2(p[0], p[1]); sort_2(p[2], p[3]); sort_2(p[4], p[5]);
                sort_2(p[1], p[4]); sort_2(p[3], p[6]);
                sort_2(p[1], p[2]); sort_2(p[3], p[4]); sort_2(p[5], p[6]);
              }
            ```);
          }

          +p{
            続いて、2要素のソートを行う関数を定義する必要がありますが、conditional move 命令を
            利用することで条件分岐を完全に廃することを目指します。
            手元の環境（gcc 10.2.0 -O3）では、次のように記述することで conditional move 命令が
            発行されました。
            Clang 10.0.1 -O3 では `a < b ? a : b` の代わりに `min(a, b)` でも可でしたが、
            gcc では不可です。

            \d-code(```
              void sort_2(int &a, int &b) {
                int minv = a < b ? a : b;
                int maxv = a >= b ? a : b;
                a = minv;
                b = maxv;
              }
            ```);
          }

          +p{
            と、ここまでソートの高速化について1ページ強を費やしてしまいましたが、
            ソートの高速化によって短縮された計算時間はランダムアクセス（1億ハンド）で3秒程度でした。
            ランダムアクセス（1億ハンド）の全体の計算時間は58.8秒ですから、
            ボトルネックは普通にハッシュテーブルを引く処理であって、
            ソートの部分を高速化しても正直あまり嬉しくなかったですね。
            前計算した結果がメモリに収まるからと言って、安直にハッシュテーブルを用いるだけでは、
            5枚のカードをナイーブに評価する実装よりも遅くなってしまって
            使い物にならないことが分かりました。
          }
        >

        +subsection?:(`evaluator-vector`){前計算に基づく巨大なテーブルを用いる実装（その２）} <
          +listing{
            * \dfn{シーケンシャル速度}（1.33億ハンド）: 7.54秒（1770万評価/秒）
            * \dfn{ランダムアクセス速度}（1億ハンド）: 10.3秒（969万評価/秒）
            * \dfn{メモリ使用量}: 256MB
          }

          +p{
            \ref-subsection(`evaluator-hash-table`); のハッシュテーブルを用いた実装は、
            ハッシュテーブルを引くのが遅い上にメモリ使用量も定数倍が大きく5GB以上を消費し、
            良いことがありませんでした。
            カード7枚の組が与えられたときに、 0 ～ 133,784,559 の範囲の一意な整数を
            何らかの方法で直接対応させることができれば、ハッシュテーブルではなく
            単に配列を用意すれば良くなるのですが、そのようなことは可能なのでしょうか。
          }

          +p{
            ここで \dfn{Combinatorial number system} の出番です。
            実は、カード ${c_7 > c_6 > \cdots > c_1 \geq 0} が与えられたときに、
            カードの組 ${\(c_7, c_6, \cdots, c_1\)} が辞書順で何番目に現れるかというと、

            \eqn(${
              \(c_7\ \text!{choose}\ 7\) + \(c_6\ \text!{choose}\ 6\)
              + \cdots + \(c_1\ \text!{choose}\ 1\)
            });

            番目であることが知られています。
            この式を利用して、ハッシュテーブルを用いない効率的なテーブルの参照を行ってみましょう。
          }

          +p{
            まずは、n choose k を毎回計算するのを避けるため、これらを変数に代入します:

            \d-code(`
              // comb[i][j] は i choose (j + 1) を表す
              vector<vector<int>> comb(52, vector<int>(7));

              void prepare_comb_table() {
                for (int i = 0; i < 52; ++i) {
                  comb[i][0] = i;
                  for (int j = 1; j < 7; ++j) {
                    comb[i][j] = comb[i][j - 1] * (i - j) / (j + 1);
                  }
                }
              }
            `);
          }

          +p{
            変数 `comb` を前計算したら、実際にテーブルを引く処理は次のように記述できます:

            \d-code(`
              // 配列は前計算しておく
              vector<uint16_t> vec;

              uint16_t evaluate_hand_vector(const vector<int> &hand) {
                int sorted[7];
                copy(hand.begin(), hand.end(), sorted)
                sort_7(sorted);
                int key = comb[sorted[0]][0] + comb[sorted[1]][1] + comb[sorted[2]][2]
                        + comb[sorted[3]][3] + comb[sorted[4]][4] + comb[sorted[5]][5]
                        + comb[sorted[6]][6];
                return vec[key];
              }
            `);
          }

          +p{
            このように、ハッシュテーブルを用いていた部分を単なる配列に変更することで、
            メモリ使用量は5.5GBから256MBにまで減少し、ランダムアクセス速度（1億ハンド）も
            10.3秒にまで短縮されました。
            ただし、それでも7枚のカードをナイーブに直接評価する実装の1.7～2.5倍程度の
            時間が掛かっており、ナイーブな実装の優秀さが際立っていますね。
            多少の工夫では前計算を施しても太刀打ちできないナイーブな実装に対して、
            どのように高速化を考えていけば良いのでしょうか。
          }
        >

        +subsection?:(`evaluator-twoplustwo`){前計算に基づく巨大なテーブルを用いる実装（その３）} <
          +listing{
            * \dfn{シーケンシャル速度}（1.33億ハンド）: \dfn{0.06秒（22.3億評価/秒）}
            * \dfn{ランダムアクセス速度}（1億ハンド）: 6.61秒（1510万評価/秒）
            * \dfn{メモリ使用量}: 124MB
          }

          +p{
            \ref-subsection(`evaluator-hash-table`); と \ref-subsection(`evaluator-vector`); で
            見てきた前計算に基づくテーブルを用いる実装では、入力の組を正規化するために
            ソートを行っていましたが、今度はこのソートを行わずにテーブルを引く方法を模索します。
            鍵となる観察は、例えば「\spade{K} ${\to} \heart{8}」と読んだ状態と、
            「\heart{8} ${\to} \spade{K}」と読んだ状態は同じ状態であるという点です。
            つまり、\dfn-ja-en{有向非巡回グラフ}{Directed acyclic graph\; DAG}を
            辿っていくことを考えると、「\spade{K} ${\to} \heart{8}」を読んだ場合と
            「\heart{8} ${\to} \spade{K}」を読んだ場合が同じ頂点（ノード）に辿り着くように
            グラフを構成すれば良さそうなことが分かります。
          }

          +p{
            さらにこのグラフを最適化することを考えると、例えば
            「\spade{K} ${\to} \heart{8} ${\to} \diamond{6} ${\to} \club{9}」と
            「\spade{K} ${\to} \heart{8} ${\to} \club{6} ${\to} \diamond{9}」は
            後半の6と9のスートが異なりますが、どちらもフラッシュの可能性が無いため、
            役判定の観点からはこれまでに出現したランク（K、9、8、6）の情報のみを保持すればよく、
            これらも同じ状態として扱って良いことが分かります。
            このようにして構成されたグラフは実は124MBの容量に収まることが知られており、
            2006年頃にTwo Plus Twoというフォーラムで考案されたことから“Two Plus Two evaluator”
            などと呼ばれています。

            \d-code(`
              // 構成されたグラフを予めロードしておく
              vector<int> hand_ranks(32487834);

              int evaluate_hand_twoplustwo(const vector<int> &hand) {
                int p = 53;
                for (int i = 0; i < 7; ++i) {
                  p = hand_ranks[hand[i] + p];
                }
                return p;
              }
            `);
          }

          +p{
            評価関数は以上のように極めて単純なコードで記述することができ、
            シーケンシャル速度（1.33億ハンド）は驚異の0.06秒を記録しました。
            それに対してランダムアクセス速度（1億ハンド）は6.61秒とスループットが
            1/150以下になっており、ランダムアクセスには弱いことが分かります。
            これは、処理は極めて単純であるものの、ランダムアクセスの場合はキャッシュヒット率が
            非常に悪いことに起因しているものと思われます。
            巨大なテーブルを用いる方法が根本的に抱えている問題が浮き彫りになってしまった形で、
            ランダムアクセス速度を高速化するには、テーブルの大きさをキャッシュに乗る大きさに
            収めないと意味が無さそうなことが分かってきましたね。
          }
        >

        +subsection?:(`evaluator-cactus-kev`){Cactus Kevによる実装} <
          +listing{
            * \dfn{シーケンシャル速度}（1.33億ハンド）: 10.1秒（1330万評価/秒）
            * \dfn{ランダムアクセス速度}（1億ハンド）: 10.5秒（953万評価/秒）
            * \dfn{メモリ使用量}: 48KB
          }

          +p{
            紹介する順序と歴史的な順序が前後してしまいましたが、
            本節ではCactus Kevというポーカープレイヤー兼プログラマーが2002年頃に発明し、
            2006年頃にPaul Senzeeというプログラマーによって改良された実装を紹介します。
          }

          +p{
            まず第一の発明として、各カードを0～51の整数で表現するのではなく、
            次に示す32ビット整数として表現することを考えました:

            \d-code(`
              32-bit representation = |xxxAKQJT|98765432|cdhsrrrr|xxpppppp|
              p: r番目の素数 (2->2, 3->3, ..., A->41)
              r: ランクの4ビット表現 (2->0, 3->1, ..., A->12)
              cdhs: スートのビットフラグ (例えばスペードなら0001となる)
              AK...2: ランクのビットフラグ (例えば4なら00000|00000100となる)
            `);
          }

          +p{
            このように表現を行うと、5枚のカードからなるハンドの役判定の大枠は
            次のように記述することができます:

            \d-code(`
              uint16_t evaluate_hand_internal(int c1, int c2, int c3, int c4, int c5) {
                // ランクのビットフラグの論理和 (最大値は0x1f00 = 7936)
                int q = (c1 | c2 | c3 | c4 | c5) >> 16;

                // フラッシュかどうかの判定
                if (c1 & c2 & c3 & c4 & c5 & 0xf000) {
                  // 変数qでテーブルを引く
                  return flushes[q];
                }

                // テーブルを引いてストレートおよびハイカードの場合を処理
                if (unique5[q]) {
                  return unique5[q];
                }

                // フラッシュ/ストレート/ハイカードのいずれでもない場合の処理
                return ???;
              }
            `);
          }

          +p{
            フラッシュ/ストレート/ハイカードの場合の処理はたった7,937要素のテーブルを引くだけで
            行えるようになり、これまでのキャッシュヒットの問題は解決することができました。
            問題は残る場合の処理ですが、すでにフラッシュではないことが分かっているため、
            ランクの組み合わせのみによって役が決まることを利用します。
            ここで、32ビット表現の下位6ビットに相異なる素数を割り当てたことを思い出すと、
            これらの積がランクの組み合わせを表現するのに最適です。
          }

          +p{
            それでは、ランクの組み合わせを表現する積は何通りの値を取り得るかを考えてみましょう。
            まず、簡単のため各ランクのカードが無限に存在すると仮定すると（実際には4枚ですが）、
            それらの中から5枚を選ぶ場合の数は (13 + 5 - 1) choose 5 = 6,188 通りです。
            この中には同じランクを5枚選んでいる場合が13通りだけ含まれてしまっているので、
            実際には 6,188 - 13 = 6,175 通りとなることが分かります。
            さらに、今回は5枚のランクが相異なる場合を除外しているので、
            それら 13 choose 5 = 1,287 通りを差し引くと、最終的に4,888通りが残ることになります。
          }

          +p{
            よって、理論的には4,888要素のテーブルを用意すれば、
            そのテーブルを引くことで役判定が行えることになります。
            問題はそのテーブルをどのように引くかですが、ここに\dfn-ja-en{完全ハッシュ関数}
            {Perfect hash function}を用いることを考えたのがPaul Senzeeというプログラマーです。
            完全ハッシュ関数とは、定義域が定まっているときにそれらの入力に対して単射であるような
            （つまり衝突が無い）ハッシュ関数のことで、Paul Senzeeは具体的に以下のような
            マジカルな実装を与えました:

            \d-code(`
              unsigned find_fast(unsigned u) {
                  unsigned a, b, r;
                  u += 0xe91aaa35;
                  u ^= u >> 16;
                  u += u << 8;
                  u ^= u >> 4;
                  b = (u >> 8) & 0x1ff;
                  a = (u + (u << 2)) >> 19;
                  r = a ^ hash_adjust[b];
                  return r;
              }
            `);
          }

          +p{
            ここで、`hash_adjust` は要素数512のマジカルな配列ですが、この関数を用いると
            前述した4,888通りの積を13ビットの一意な整数に変換することができます。
            よって、8,192要素の配列 `hash_values` を前計算することで、
            フラッシュ/ストレート/ハイカードのいずれでもない場合の処理は
            次のように記述できるようになりました。

            \d-code(`
              return hash_values[find_fast(
                (c1 & 0xff) * (c2 & 0xff) * (c3 & 0xff) * (c4 & 0xff) * (c5 & 0xff)
              )];
            `);
          }

          +p{
            ここまでに用意したテーブルの容量は48KB程度と、これまでに見てきたテーブルとは
            桁違いに容量を削減できており、これならキャッシュヒット率も問題ありません。
            7枚のカードからなるハンドを評価するには 7 choose 5 通りの5枚組を
            評価しなければなりませんが、ランダムアクセス速度（1億ハンド）は10.5秒と、
            \ref-subsection(`evaluator-naive`); に示した最もナイーブな実装と比べると5倍程度高速です。
            7枚のカードを直接評価する \ref-subsection(`evaluator-naive-7`); の実装と比較してしまうと
            やはり遅いですが、7枚のうちどの5枚が用いられたかを復元する必要がある場合などは
            こちらを使用した方が簡潔に処理できるかもしれません。
          }
        >
      >
    >
  >

end
