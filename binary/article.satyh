@require: itemize
@require: code

@require: class-yabaitech/yabaitech

@import: lib

module Binary : sig

  val article : block-text

end = struct

  open BinaryCommands

  let-inline \dfn-ja-en ja en = {\dfn{#ja; (#en;)}}

  let-math \empty = ${}

  let-math \choose m n = ${\empty_{#m}\mathrm{C}_{#n}}

  let article = '<
    +chapter(|
      bibliography = [];
      title = {テキサスホールデムの役判定に見る高速化テクニック};
      title-for-toc = Option.none;
      subtitle = Option.none;
      author = {ばいなり};
    |)
    <
      +section{はじめに} <
        +p{
          はじめまして、 yabaitech.tokyo の新メンバーのばいなりです。
          yabaitech.tokyo のメンバーの一部でテキサスホールデムポーカーが流行っており、
          一緒にポーカーで遊んでいたらこちらに加入させられてしまいました。
          せっかくなのでポーカーに関する技術記事を書こうということで、
          今回はテキサスホールデムの役判定を爆速で行う話についてでも書かせてもらえればと思います。
        }

        +p{
          所詮はポーカーの役判定ごとき、もともと愚直に書いてもマイクロ秒単位で処理できるため、
          もともと高速じゃないか、そんなものを高速化して何が面白いのかと思われるかもしれませんが、
          次章で説明するようにテキサスホールデムポーカーでは使えるカードが
          明らかになっていない段階でアクションを起こす必要があり、
          その時点での勝率を計算しようとすると大量にあり得るハンドの役判定を行わねばならず、
          この処理の高速化が要求されるわけです。
          限定的な条件下ではありますが、中には1秒間に22億回もの評価が行えるプログラムまで
          登場しますので、楽しみに読み進めていただければ幸いです。
        }
      >

      +section{テキサスホールデムのルール} <
        +p{
          \dfn-ja-en{テキサスホールデム}{Texas hold'em} は、数あるポーカーの変種の中でも
          世界的に見て最もポピュラーなものと言えるゲームです。
          日本ではまだ馴染みの薄い感じもありますが、世界的には数多くのプレイヤーがおり、
          最も権威ある世界大会ではなんと10,000,000ドル (!) もの優勝賞金が懸けられるほどです。
          この章では、テキサスホールデムとは何ぞやという方に向けて、そのルールを簡単に説明します
          （テキサスホールデムを既に知っている方は読み飛ばしていただいても構いません）。
        }

        +subsection?:(`list-of-poker-hands`){役の一覧} <
          +p{
            テキサスホールデムにおける役は5枚のカードの組み合わせで決まり、
            強い順に以下の9つがあります。
            さまざまなポーカーの変種で共通なため、馴染みのある方も多いでしょう。
          }

          +enumerate{
            * \dfn-ja-en{ストレートフラッシュ}{Straight flush}:
              フラッシュとストレートの複合役。すべての役の中で最も強い。
              例: \spade{A} \spade{K} \spade{Q} \spade{J} \spade{10}
            * \dfn-ja-en{フォーカード}{Four of a kind}:
              同じランク（数字）のカードを4枚集めた役。
              例: \spade{6} \heart{6} \diamond{6} \club{6} \diamond{J}
            * \dfn-ja-en{フルハウス}{Full house}:
              同じランクのカード3枚と、別の同じランクのカード2枚で構成される役。
              例: \heart{K} \diamond{K} \club{K} \heart{3} \club{3}
            * \dfn-ja-en{フラッシュ}{Flush}:
              同じスート（柄）のカードを5枚集めた役。
              例: \heart{Q} \heart{10} \heart{7} \heart{5} \heart{4}
            * \dfn-ja-en{ストレート}{Straight}:
              数字が連続した5枚のカードで構成される役。
              Aは14または1として扱うことができる。
              A、K、2の3枚を含むものはストレートとは見なされない。
              例: \heart{J} \club{10} \club{9} \heart{8} \spade{7}
            * \dfn-ja-en{スリーカード}{Three of a kind}:
              同じランクのカードを3枚集めた役。
              例: \spade{5} \diamond{5} \club{5} \heart{A} \club{J}
            * \dfn-ja-en{ツーペア}{Two pair}:
              同じランクのカード2枚の組を2組集めた役。
              例: \spade{8} \club{8} \spade{3} \diamond{3} \diamond{Q}
            * \dfn-ja-en{ワンペア}{One pair}:
              同じランクのカードを2枚集めた役。
              例: \diamond{7} \club{7} \spade{9} \spade{4} \diamond{2}
            * \dfn-ja-en{ハイカード}{High card}:
              上記のいずれにも当てはまらないもの。いわゆる“ブタ”。
              例: \club{A} \spade{J} \diamond{8} \club{4} \heart{2}
          }

          +p{
            役が同じ場合は、カードのランクをもとにタイブレークがなされます
            （Aが最も強く、2が最も弱い\; ストレートでAを1として扱った場合のみAが最も弱い）。
            カードのスートはハンドの強さに影響しません。
            このようにハンドの強さを定義した場合、
            ハンドは7462種の同値類に分類されることが知られています。
          }
        >

        +subsection{テキサスホールデムの進行} <
          +p{
            テキサスホールデムでは、\dfn-ja-en{ホールカード}{Hole cards}と呼ばれる
            各プレイヤーに2枚ずつ配られるカードと、\dfn-ja-en{コミュニティカード}{Community cards}
            と呼ばれるプレイヤー全員が使用できる5枚の共通のカードの計7枚の中から、
            最も強い5枚の組み合わせを用いてハンドの強さを競います。
            よくあるクローズドポーカーとは異なり、配られた手札を交換することはできません。
            最終的に手札を公開してハンドの強さを競うことになった場合
            （これを\dfn-ja-en{ショーダウン}{Showdown}と呼ぶ）、
            より強いハンドを持っていたプレイヤーが
            それまでに賭けられてきた\dfn-ja-en{ポット}{Pot}を総取りします。
          }

          +p{
            ただし、実際の進行ではショーダウンが行われることはそれほどありません。
            というのも、他のプレイヤーを全員“降ろす”ことができれば、
            その時点でポットは残った1人のプレイヤーのものとなるためです。
            ベッティングラウンドでは、賭け金の合意が取れるまで各プレイヤーは定められた順序で
            以下のいずれかのアクションを取る必要があります:
          }

          +listing{
            * \dfn-ja-en{ベット}{Bet} / \dfn-ja-en{レイズ}{Raise}:
              現在の賭け金からさらに賭け金を上乗せするアクションです。
              賭け金がゼロの状態から行うアクションをベット、
              既にベットされている状態から行うアクションをレイズと言います。
            * \dfn-ja-en{チェック}{Check} / \dfn-ja-en{コール}{Call}:
              現在の賭け金に同意し、同額を支払ってプレイを継続するアクションです。
              追加の賭け金が必要無い状態で行うアクションをチェック、
              賭け金を追加で支払う必要のある状態で行うアクションをコールと言います。
            * \dfn-ja-en{フォールド}{Fold}:
              現在の賭け金を支払わず、手札を捨てて勝負から降りるアクションです。
              フォールドを行うと、それ以降のベッティングラウンドにも参加できず、
              ポットを獲得する権利を完全に失います。
          }

          +p{
            テキサスホールデムでは、ショーダウンまでに4回のベッティングラウンドを行います:
          }

          +listing{
            * \dfn-ja-en{プリフロップ}{Pre-flop}:
              2枚のホールカードが配られた直後に行われるラウンドです。
              コミュニティカードは1枚も公開されません。
              プリフロップでは、\dfn-ja-en{スモールブラインド}{Small blind}と
              \dfn-ja-en{ビッグブラインド}{Big blind}と呼ばれる2人のプレイヤーは
              定められた額のベットを強制的に行わなければなりません。
            * \dfn-ja-en{フロップ}{Flop}:
              コミュニティカードが3枚公開された状態で行われるラウンドです。
            * \dfn-ja-en{ターン}{Turn}:
              4枚目のコミュニティカードが公開された状態で行われるラウンドです。
            * \dfn-ja-en{リバー}{River}:
              5枚目のコミュニティカードが公開され、すべてのコミュニティカードが
              明らかになった状態で行われるラウンドです。
          }

          +p{
            特にプリフロップの段階では、最終的に使用できる7枚のカードのうち2枚しか
            明らかになっていません。この時点での勝率の計算などを厳密に行おうとすると、
            大量にあり得るハンドの役判定が必要になるという冒頭の主張に繋がるわけです。
          }
        >
      >

      +section{レギュレーション} <
        +p{
          さて、以上に説明したテキサスホールデムのルールを踏まえて、
          作りたいプログラムの要件を定義していきましょう。
          今回の目標は「7枚のカードの組が与えられたときの役の判定」を行うプログラムであって、
          なるべく高速なものを作ることです。
          もう少し厳密に書くと、次の要件を満たすようななるべく高速な関数の実装を目指します。
        }

        +listing{
          * 7枚のカードで構成されるハンドを入力として受け取って非負整数を返す関数であって、
            \ref-subsection(`list-of-poker-hands`); に示したようにハンドの強さを定義したとき、
            より強いハンドが入力として与えられた場合はより大きい整数を返し、
            強さが同じハンドが入力として与えられた場合は同じ整数を返すようなもの
            （特に、役が同じであっても多くの場合はタイブレークによる強弱が存在することに注意する）。
        }

        +p{
          なお、各カードは0～51の整数で表現されているものとし、
          0～3が\club{2} \diamond{2} \heart{2} \spade{2}、
          4～7が\club{3} \diamond{3} \heart{3} \spade{3}、${\cdots}、
          48～51が\club{A} \diamond{A} \heart{A} \spade{A}に対応しているものとします。
        }

        +p{
          今回は勝率計算などに用いるサブルーチンとしての役判定を想定しているため、
          プログラムの高速化のために次のような機能は含めなくてよいものとします:
        }

        +listing{
          * ハンドが7枚未満の場合の役判定を行う機能。
          * 7枚のカードのうちどの5枚が用いられたかを示す機能。
          * 入力のバリデーションチェック。すなわち、入力長は7であり、入力の各要素は
            0～51の整数であって相異なることを仮定する。
        }

        +p{
          プログラムは以下の3点によって評価されます:
        }

        +listing{
          * \dfn{シーケンシャル速度}:
            ${\choose{52}{7}}（＝133,784,560）通りの7枚のカードの組み合わせについて
            辞書順にハンドの評価を行い、掛かった時間を計測する。
            この測定では、ハンドを表現する何らかのデータ構造にカードを追加する操作は
            最内ループの外で行っても良いものとする。
            すなわち、以下のようなプログラムが認められる:

            \d-code(```
              Hand hand = Hand();
              for (int card1 = 0; card1 < 46; ++card1) {
                // add_card()の複雑さに関わらず、この操作を以降のループ中に含めなくてよい
                Hand hand1 = hand.add_card(card1);  // handにcard1を追加した結果を返す
                for (int card2 = card1 + 1; card2 < 47; ++card2) {
                  Hand hand2 = hand1.add_card(card2);
                  // 3枚目以降のカードの処理...
                }
              }
            ```);

          * \dfn{ランダムアクセス速度}:
            1億通りのランダムなハンドについて評価を行い、掛かった時間を計測する。
            この測定では、0～51の整数からなる要素数7のランダムな配列のみが予め用意される。
            なお、配列の要素はソートされているとは限らない。
            ハンドを表現する何らかのデータ構造にカードを追加する操作が必要な場合は
            毎回ゼロから行う必要があり、その時間も計測結果に反映される。

          * \dfn{メモリ使用量}:
            これから紹介するプログラムには、予め前計算したテーブルを用いるものが含まれるため、
            そういった静的なテーブルの大きさを示す（実行時のメモリ使用量を計測したものではない）。
            静的なテーブルを用いない場合は「極小」と表記する。
        }

        +p{
          プログラムの記述言語にはC++17（g++ 10.2.0 -O3 -march=native）を採用します。
          また、実行時間の計測には筆者のデスクトップマシン（Ryzen 7 3700X CPU）を用います。
        }

        +p{
          それでは、次章でさまざまな実装について見ていきましょう！
        }
      >

      +section{さまざまな実装} <
        +subsection?:(`evaluator-naive`){ナイーブな実装} <
          +listing{
            * \dfn{シーケンシャル速度}（1.33億ハンド）: 58.0秒（231万評価/秒）
            * \dfn{ランダムアクセス速度}（1億ハンド）: 50.0秒（200万評価/秒）
            * \dfn{メモリ使用量}: 極小
          }

          +p{
            何はともあれ、まずはベースラインとなるナイーブな実装について見ていきましょう。
            7枚のカードから5枚を選ぶ${\choose{7}{5}}＝21通りの選び方を予め定数として用意しておき、
            その組み合わせをすべて試して最も強かった結果を返すというのが
            ナイーブな実装の大枠になるかと思います。
          }

          +p{
            5枚のカードからなるハンドの評価を行う関数 `evaluate_naive_5()` については
            後ほど見ていくことにして、プログラムを記述していくと次のようになるでしょう:

            \d-code(```
              // 7 choose 5の組み合わせを予め定数として持っておく
              const int comb_7_5[21][5] = {
                { 0, 1, 2, 3, 4 }, { 0, 1, 2, 3, 5 }, (中略), { 2, 3, 4, 5, 6 }
              };

              // 7枚のカードからなるハンドの強さを評価する
              int evaluate_naive(const vector<int> &hand) {
                int best = 0;
                vector<int> subhand(5);
                for (int i = 0; i < 21; ++i) {
                  for (int j = 0; j < 5; ++j) {
                    subhand[j] = hand[comb_7_5[i][j]];
                  }
                  best = max(best, evaluate_naive_5(subhand));
                }
                return best;
              }
            ```);
          }

          +p{
            それでは、関数 `int evaluate_naive_5(const vector<int> &hand);` を続いて
            定義していきましょう。ナイーブとは言えども、ビット演算を利用した効率的な実装を
            目指すこととし、まずは出現したスートとランクを管理するビットセットと、
            各ランクの出現回数を管理する変数を準備します。

            \d-code(```
              int suitset = 0;
              int rankset = 0;
              int rankcount[13] = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };
              for (int card : hand) {
                int suit = card % 4;
                int rank = card / 4;
                suitset |= 1 << suit;
                rankset |= 1 << rank;
                ++rankcount[rank];
              }
            ```);

            さらに、出現回数からランクのビットセットを逆引きできる変数も準備します。

            \d-code(```
              int rankset_of_count[5] = { 0, 0, 0, 0, 0 };
              for (int rank = 0; rank < 13; ++rank) {
                rankset_of_count[rankcount[rank]] |= 1 << rank;
              }
            ```);

            以上の変数が用意できれば、フラッシュとストレートの判定は以下のように行えます。

            \d-code(```
              bool is_flush = count_ones(suitset) == 1;
              int is_straight = rankset & (rankset << 1) & (rankset << 2)
                              & (rankset << 3) & (rankset << 4);
              if (rankset == 0b1'0000'0000'1111) is_straight = 1 << 3;
            ```);

            ここで、`count_ones()` は2進数表記でのビットの立っている数を返す関数とします
            （gcc/clang における `__builtin_popcount()` と同様）。
            フラッシュの判定は明らかですが、ストレートの判定については解説が必要かもしれません。
            ストレートが成立している場合、ランクのビットセットは5桁連続でビットが立っている
            ことになります（5432Aの場合を除く）。このとき、ビットを0～4桁ズラしたもの同士で
            ビット論理積を取るとその結果は非ゼロとなります。

            \d-code(```
                0000000111110 (x)
              & 0000001111100 (x << 1)
              & 0000011111000 (x << 2)
              & 0000111110000 (x << 3)
              & 0001111100000 (x << 4)
              ------------------------
                0000000100000
            ```);

            逆に、ストレートが成立していない場合は、このビット論理積はゼロとなります。
            よって、唯一の例外である5432Aのストレートについて最後にケアしてあげれば、
            変数 `is_straight` は非ストレートの場合はゼロ、またストレートの場合は非ゼロでかつ
            最もランクの大きいカードの情報が入っている状態となります。
          }

          +p{
            ここまで準備ができれば、あとはナイーブに役判定を行っていくのみです。
            ここで返り値のフォーマットについて考える必要がありますが、
            上位4ビットに役の情報を、下位26ビットにタイブレークに関する情報を埋め込んだ
            30ビットの整数を用いることにしましょう。

            \d-code(```
              if (is_flush && is_straight) {
                // straight flush
                return (8 << 26) | is_straight;
              } else if (rankset_of_count[4]) {
                // four of a kind
                return (7 << 26) | (rankset_of_count[4] << 13) | rankset_of_count[1];
              } else if (rankset_of_count[3] && rankset_of_count[2]) {
                // full house
                return (6 << 26) | (rankset_of_count[3] << 13) | rankset_of_count[2];
              } else if (is_flush) {
                // flush
                return (5 << 26) | rankset;
              } else if (is_straight) {
                // straight
                return (4 << 26) | is_straight;
              } else if (rankset_of_count[3]) {
                // three of a kind
                return (3 << 26) | (rankset_of_count[3] << 13) | rankset_of_count[1];
              } else if (rankset_of_count[2]) {
                // two pair or one pair
                int num_pairs = count_ones(rankset_of_count[2]);
                return (num_pairs << 26) | (rankset_of_count[2] << 13) | rankset_of_count[1];
              } else {
                // high card
                return (0 << 26) | rankset;
              }
            ```);
          }

          +p{
            以上がナイーブな実装についてでしたが、これだけで予想外に3ページ半も
            費やしてしまいました。タイブレークまで正確に考慮した実装を簡潔に記述するのは
            案外簡単ではないのではということで丁寧に解説してみましたが、いかがでしたでしょうか。
          }
        >

        +subsection?:(`evaluator-naive-7`){7枚のカードを直接評価する実装（ナイーブ）} <
          +listing{
            * \dfn{シーケンシャル速度}（1.33億ハンド）: 2.77秒（4830万評価/秒）
            * \dfn{ランダムアクセス速度}（1億ハンド）: 3.14秒（3190万評価/秒）
            * \dfn{メモリ使用量}: 極小
          }

          +p{
            \ref-subsection(`evaluator-naive`); で紹介したナイーブな実装は ${\choose{7}{5}} 通りの
            カードの選び方をすべて試すものでしたが、7枚のカードが与えられたときにそれらを
            直接評価する戦略も考えられます。
            例えば、\club{K} \diamond{10} \club{8} \club{4} \heart{4} \spade{4} \heart{3}という
            ハンドが与えられたとき、人間は ${\choose{7}{5}} 通りのカードの選び方を
            すべて考えなくとも、まず4のスリーカードを認識し、残ったカードのうちランクの高い
            \club{K}と\diamond{10}を加えた\club{4} \heart{4} \spade{4} \club{K} \diamond{10}が
            最終的な5枚組になることを把握できるでしょう。
          }

          +p{
            このような戦略に基づく実装を正確に書き下すのは、5枚のハンドを評価する実装と比べてさらに
            注意力を要しますが、丁寧に考察をしていけばそれなりに簡潔に記述することが可能です。
            まずはユーティリティ関数として、立っているビットのうち上位から`n`ビットを保持する関数を
            定義しましょう:

            \d-code(```
              int keep_n_msb(int x, int n) {
                int result = 0;
                for (int i = 0; i < n; ++i) {
                  int m = msb(x);
                  x ^= m;
                  result |= m;
                }
                return result;
              }
            ```);

            ここで、 `msb(x)` は入力 `x` の立っているビットのうち
            最上位のビットのみが立った値を返す関数とします
            （gcc/clangでは `int` 型に対しては `1 << (__builtin_clz(x) ^ 31)` として定義できます）。
            このような関数を用意できると、先ほどの例のようなスリーカードの処理は次のように
            書き下すことができます:

            \d-code(```
              // スリーカードより強い役ではないことが確認できているとする
              if (rankset_of_count[3]) {
                // three of a kind
                int remaining = keep_n_msb(rankset_of_count[1], 2);
                return (3 << 26) | (rankset_of_count[3] << 13) | remaining;
              }
            ```);

            本節では実装のすべての紹介は行いませんが、この戦略に基づく実装を実際に書いてみようと
            いう場合は、ストレートとフラッシュが両方成立しているからといってストレートフラッシュとは
            限らない点（ストレートフラッシュは同じスート内でストレートを完成させる必要がある）、
            3枚組が2つある場合の処理（フルハウス）、2枚組が3つある場合の処理（ツーペア）などに
            気をつけてみてください。
          }

          +p{
            筆者の実装では、\ref-subsection(`evaluator-naive`); の実装と比べて
            16～21倍程度の高速化を実現することができました。
            どの5枚が最終的に用いられたかの情報を復元する処理は自明には書けなくなって
            しまいましたが、それと引き換えにこれだけの高速化が施せれば十分でしょう。
          }

          +p{
            このような記事を書いておいて言うのも微妙ですが、ポーカーの役判定が必要となるような
            場面のほとんどは、\ref-subsection(`evaluator-naive`); と本節に示したような
            ナイーブな処理で正直間に合うようにも思います。
            ここからさまざまなテクニックを用いて処理を高速化していくわけですが、
            最終的に得られるプログラムは本節のものと比べてシーケンシャル速度で17倍、
            ランダムアクセス速度で7.5倍速いという程度に留まります。
            この7.5～17倍を引き出す過程が面白いと感じたからこそこのような記事を
            書いているわけではありますが、7.5倍遅い程度で済むなら明快な処理の方が好ましいという
            状況も少なくないのではないでしょうか。
            また、ナイーブな実装は高速な実装の動作をテストする際にも役に立ちますので、
            ナイーブなものが悪いということでは決してない点は留意していただければと思います。
          }
        >

        +subsection?:(`evaluator-hash-table`){前計算に基づく巨大なテーブルを用いる実装（その１）} <
          +listing{
            * \dfn{シーケンシャル速度}（1.33億ハンド）: 9.11秒（1470万評価/秒）
            * \dfn{ランダムアクセス速度}（1億ハンド）: 33.0秒（303万評価/秒）
            * \dfn{メモリ使用量}: 約5.5GB
          }

          +p{
            繰り返しですが、52枚のカードのうち7枚を取り出す場合の数は
            ${\choose{52}{7}}＝133,784,560 通りです。
            これらの約1.33億通りの場合について予め前計算を行ってテーブルとして
            保存してしまうことを考えると、各要素を2バイト整数で表現した場合
            （前述したようにハンドの強さは7462種類の同値類に分類できるため2バイト整数で表現可能）、
            高々256MBの容量に収まることが分かります。
            この256MBという容量は、例えばアプリに組み込むことを考えるとこれだけですでに
            許容できない容量で、後述するようにハッシュテーブル等を用いてしまうとさらに定数倍が
            掛かってしまいますが、ローカルで計算を行う分には何とかなるでしょう。
            ここからは、このように予め約1.33億通りの場合をすべて前計算してしまって、
            その結果を利用することで高速化が図れないかを考えていきます。
          }

          +p{
            まず問題となるのは、0～51の整数で表現されたカード7枚の組が与えられたときに、
            どうやってテーブルを引くのかという点です。
            つまり、カード7枚の組を何かしらのフォーマットに正規化する方法を考える必要があります。
            ここでは、カードを表す整数7つをソートして順序を一意にした上で、
            それらを8ビット整数として並べた56ビット整数として表現することにしてみましょう。
            このようにフォーマットを定めてさえしまえば、あとは探索木なりハッシュテーブルなりで
            検索を行うことが可能になります。
            例えば、ハッシュテーブルを用いた実装は次のようになるでしょう:

            \d-code(```
              // ハッシュテーブルは前計算しておく
              unordered_map<uint64_t, uint16_t> hash_table;

              uint16_t evaluate_with_hash_table(const vector<int> &hand) {
                int sorted[7];
                copy(hand.begin(), hand.end(), sorted);
                sort(sorted.begin(), sorted.end());
                uint64_t lo = sorted[0] | (sorted[1]<<8) | (sorted[2]<<16) | (sorted[3]<<24);
                uint64_t hi = sorted[4] | (sorted[5]<<8) | (sorted[6]<<16);
                return hash_table[lo | (hi << 32)];
              }
            ```);
          }

          +p {
            さてこれにて一件落着…としたいところなのですが、せっかく高速化の記事ですので
            この実装をさらに高速にすることを考えましょう。
            ここで注目するのは `sort()` を呼び出している部分です。
            C++ STL（標準ライブラリ）のソート関数は汎用的に使用できるものですが、
            今回は要素数が7であることが分かっているため、このことを利用します。
          }

          +p{
            小さい配列のソートのような処理においてボトルネックとなるのは、主に条件分岐です。
            CPUはヒューリスティクスによって条件分岐命令が実行される以前から分岐を予測し、
            投機的に命令を実行していますが、この予測が失敗した際にオーバーヘッドが生じます。
            小さい配列のソートにおいては、条件分岐が何回も行われる上にその予測も難しいため、
            このオーバーヘッドが問題になるわけです。
          }

          +p{
            そこで、ここでは\dfn{ソーティングネットワーク}を用いることにします。
            ソーティングネットワークに関する詳細な説明はWikipedia等に譲りますが、
            簡単に言えば2要素のソートを定められた順序で複数回繰り返すことで
            ソートを実現するという手法です。
            この“定められた順序で”というのが重要で、比較の順序がそれまでの比較結果によらないため、
            比較の順序に関する分岐を廃することが可能で、並列実行に向いたアルゴリズムでもあります。
          }

          +p{
            7要素のソートの場合は、2要素のソートを16回行うことでソートを行うことが可能で、
            また16回という回数が下限である（＝最適である）ことも知られています
            （ソーティングネットワークでない一般の比較ソートでは比較回数の下限は13回となりますが、
            こちらはそれまでの比較結果に応じて比較対象が動的に変化します）。

            \d-code(```
              void sort_7(int *p) {
                sort_2(p[0], p[4]); sort_2(p[1], p[5]); sort_2(p[2], p[6]);
                sort_2(p[0], p[2]); sort_2(p[1], p[3]); sort_2(p[4], p[6]);
                sort_2(p[2], p[4]); sort_2(p[3], p[5]);
                sort_2(p[0], p[1]); sort_2(p[2], p[3]); sort_2(p[4], p[5]);
                sort_2(p[1], p[4]); sort_2(p[3], p[6]);
                sort_2(p[1], p[2]); sort_2(p[3], p[4]); sort_2(p[5], p[6]);
              }
            ```);

            続いて、2要素のソートを行う関数を定義する必要がありますが、SSE 4.1 (またはAVX) の
            (v)pminsd, (v)pmaxsd 命令を利用することで条件分岐を完全に廃することを目指します。
            手元の環境（gcc 10.2.0 -O3 -march=native）では、次のように記述することで
            vpminsd, vpmaxsd 命令が発行されました。

            \d-code(```
              void sort_2(int &a, int &b) {
                int minv = a < b ? a : b;
                int maxv = a >= b ? a : b;
                a = minv;
                b = maxv;
              }
            ```);
          }

          +p{
            ここまでのソートの高速化によって短縮された計算時間は、
            ランダムアクセス（1億ハンド）で30秒程度でした。
            高速化後のランダムアクセス（1億ハンド）の全体の計算時間は33.0秒ですから、
            計算時間を半分近くにまで削減できたことになりますが、残りの半分は普通に
            ハッシュテーブルを引く処理であって、方針を変えない限りはこれ以上の高速化は難しそうです。
            前計算した結果がメモリに収まるからと言って、安直にハッシュテーブルを用いるだけでは、
            \ref-subsection(`evaluator-naive-7`); の実装より10倍以上も遅くなってしまうことが
            分かりました。
          }
        >

        +subsection?:(`evaluator-vector`){前計算に基づく巨大なテーブルを用いる実装（その２）} <
          +listing{
            * \dfn{シーケンシャル速度}（1.33億ハンド）: 3.70秒（3610万評価/秒）
            * \dfn{ランダムアクセス速度}（1億ハンド）: 3.86秒（2590万評価/秒）
            * \dfn{メモリ使用量}: 256MB
          }

          +p{
            \ref-subsection(`evaluator-hash-table`); のハッシュテーブルを用いた実装は、
            ハッシュテーブルを引くのが遅い上にメモリ使用量も定数倍が大きく5GB以上を消費し、
            良いことがありませんでした。
            カード7枚の組が与えられたときに、 0 ～ 133,784,559 の範囲の一意な整数を
            何らかの方法で直接対応させることができれば、ハッシュテーブルではなく
            単に配列を用意すれば良くなるのですが、そのようなことは可能なのでしょうか。
          }

          +p{
            ここで \dfn{Combinatorial number system} の出番です。
            実は、カード ${c_7 > c_6 > \cdots > c_1 \geq 0} が与えられたときに、
            カードの組 ${\(c_7, c_6, \cdots, c_1\)} が辞書順で何番目に現れるかというと、

            \eqn(${
              \choose{c_7}{7} + \choose{c_6}{6} + \cdots + \choose{c_1}{1}
            });

            番目であることが知られています。
            この式を利用して、ハッシュテーブルを用いない効率的なテーブルの参照を行ってみましょう。
          }

          +p{
            まずは、${\choose{n}{k}} を毎回計算するのを避けるため、これらを変数に代入します:

            \d-code(```
              // comb[i][j] は i choose (j + 1) を表す
              vector<vector<int>> comb(52, vector<int>(7));

              void prepare_comb_table() {
                for (int i = 0; i < 52; ++i) {
                  comb[i][0] = i;
                  for (int j = 1; j < 7; ++j) {
                    comb[i][j] = comb[i][j - 1] * (i - j) / (j + 1);
                  }
                }
              }
            ```);
          }

          +p{
            変数 `comb` を前計算したら、実際にテーブルを引く処理は次のように記述できます:

            \d-code(```
              // 配列は前計算しておく
              vector<uint16_t> vec;

              uint16_t evaluate_with_vector(const vector<int> &hand) {
                int sorted[7];
                copy(hand.begin(), hand.end(), sorted)
                sort_7(sorted);
                int key = comb[sorted[0]][0] + comb[sorted[1]][1] + comb[sorted[2]][2]
                        + comb[sorted[3]][3] + comb[sorted[4]][4] + comb[sorted[5]][5]
                        + comb[sorted[6]][6];
                return vec[key];
              }
            ```);
          }

          +p{
            このように、ハッシュテーブルを用いていた部分を単なる配列に差し替えることで、
            メモリ使用量は5.5GBから256MBにまで減少し、ランダムアクセス速度（1億ハンド）も
            33.0秒から3.86秒にまで短縮されました。
            ただし、それでも \ref-subsection(`evaluator-naive-7`); の
            7枚のカードを直接評価する実装に対しては1.3倍程度の計算時間となっており、
            ナイーブな実装の優秀さが際立っていますね。
            多少の工夫では前計算を施しても太刀打ちできないナイーブな実装に対して、
            どのように高速化を考えていけば良いのでしょうか。
          }
        >

        +subsection?:(`evaluator-twoplustwo`){前計算に基づく巨大なテーブルを用いる実装（その３）} <
          +listing{
            * \dfn{シーケンシャル速度}（1.33億ハンド）: \dfn{0.06秒（22.0億評価/秒）}
            * \dfn{ランダムアクセス速度}（1億ハンド）: 6.91秒（1450万評価/秒）
            * \dfn{メモリ使用量}: 124MB
          }

          +p{
            \ref-subsection(`evaluator-hash-table`); と \ref-subsection(`evaluator-vector`); で
            見てきた前計算に基づくテーブルを用いる実装では、入力の組を正規化するために
            ソートを行っていましたが、今度はこのソートを行わずにテーブルを引く方法を模索します。
            鍵となる観察は、例えば「\spade{K} ${\to} \heart{8}」と読んだ状態と、
            「\heart{8} ${\to} \spade{K}」と読んだ状態は同じ状態であるという点です。
            つまり、\dfn-ja-en{有向非巡回グラフ}{Directed acyclic graph\; DAG}を
            辿っていくことを考えると、「\spade{K} ${\to} \heart{8}」を読んだ場合と
            「\heart{8} ${\to} \spade{K}」を読んだ場合が同じ頂点（ノード）に辿り着くように
            グラフを構成すれば良さそうなことが分かります。
          }

          +p{
            さらにこのグラフを最適化することを考えると、例えば
            「\spade{K} ${\to} \heart{8} ${\to} \diamond{6} ${\to} \club{9}」と
            「\spade{K} ${\to} \heart{8} ${\to} \club{6} ${\to} \diamond{9}」は
            後半の6と9のスートが異なりますが、どちらもフラッシュの可能性が無いため、
            役判定の観点からはこれまでに出現したランク（K、9、8、6）の情報のみを保持すればよく、
            これらも同じ状態として扱って良いことが分かります。
            このようにして構成されたグラフは実は124MBの容量に収まることが知られており、
            2006年頃にTwo Plus Twoというフォーラムで考案されたことから“Two Plus Two evaluator”
            などと呼ばれています。

            \d-code(```
              // 構成されたグラフを予めロードしておく
              vector<int> hand_ranks(32487834);

              int evaluate_two_plus_two(const vector<int> &hand) {
                int p = 53;
                for (int i = 0; i < 7; ++i) {
                  p = hand_ranks[hand[i] + p + 1];
                }
                return p;
              }
            ```);
          }

          +p{
            評価関数は以上のように極めて単純なコードで記述することができ、
            シーケンシャル速度（1.33億ハンド）は驚異の0.06秒を記録しました。
            それに対してランダムアクセス速度（1億ハンド）は6.91秒とスループットが
            1/150以下になっており、ランダムアクセスには弱いことが分かります。
            これは、処理は極めて単純であるものの、ランダムアクセスの場合はキャッシュヒット率が
            非常に悪いことに起因しているものと思われます。
            巨大なテーブルを用いる方法が根本的に抱えている問題が浮き彫りになってしまった形で、
            ランダムアクセス速度を高速化するには、テーブルの大きさをキャッシュに乗る大きさに
            収めないと意味が無さそうなことが分かってきましたね。
          }
        >

        +subsection?:(`evaluator-cactus-kev`){Cactus Kevによる実装} <
          +listing{
            * \dfn{シーケンシャル速度}（1.33億ハンド）: 10.3秒（1300万評価/秒）
            * \dfn{ランダムアクセス速度}（1億ハンド）: 10.2秒（979万評価/秒）
            * \dfn{メモリ使用量}: 48KB
          }

          +p{
            紹介する順序と歴史的な順序が前後してしまいましたが、
            本節ではCactus Kevというポーカープレイヤー兼プログラマーが2002年頃に発明し、
            2006年頃にPaul Senzeeというプログラマーによって改良された実装を紹介します。
          }

          +p{
            まず第一の発明として、各カードを0～51の整数で表現するのではなく、
            次に示す32ビット整数として表現することを考えました:

            \d-code(```
              32-bit representation = |xxxAKQJT|98765432|cdhsrrrr|xxpppppp|

              p: r番目の素数 (2->2, 3->3, ..., A->41)
              r: ランクの4ビット表現 (2->0, 3->1, ..., A->12)
              cdhs: スートのビットフラグ (例えばスペードなら0001となる)
              AK...2: ランクのビットフラグ (例えば4なら00000|00000100となる)
            ```);
          }

          +p{
            このように表現を行うと、5枚のカードからなるハンドの役判定の大枠は
            次のように記述することができます:

            \d-code(```
              uint16_t evaluate_cactus_kev_internal(int c1, int c2, int c3, int c4, int c5) {
                // ランクのビットフラグの論理和 (最大値は0x1f00 = 7936)
                int q = (c1 | c2 | c3 | c4 | c5) >> 16;

                // フラッシュかどうかの判定
                if (c1 & c2 & c3 & c4 & c5 & 0xf000) {
                  // 変数qでテーブルを引く
                  return flushes[q];
                }

                // ストレートおよびハイカードの場合はテーブルを引いて判定/処理
                if (unique5[q]) {
                  return unique5[q];
                }

                // フラッシュ/ストレート/ハイカードのいずれでもない場合の処理
                return ???;
              }
            ```);
          }

          +p{
            フラッシュ/ストレート/ハイカードの場合の処理はたった7,937要素のテーブルを引くだけで
            行えるようになり、これまでのキャッシュヒットの問題は解決することができました。
            問題は残る場合の処理ですが、すでにフラッシュではないことが分かっているため、
            ランクの組み合わせのみによって役が決まることを利用します。
            ここで、32ビット表現の下位6ビットに相異なる素数を割り当てたことを思い出すと、
            これらの積がランクの組み合わせを表現するのに最適です。
          }

          +p{
            それでは、ランクの組み合わせを表現する積は何通りの値を取り得るかを考えてみましょう。
            まず、簡単のため各ランクのカードが無限に存在すると仮定すると（実際には4枚ですが）、
            それらの中から5枚を選ぶ場合の数は ${\choose{13 + 5 - 1}{5}}＝6,188 通りです。
            この中には同じランクを5枚選んでいる場合が13通りだけ含まれてしまっているので、
            実際には 6,188 － 13 ＝ 6,175 通りとなることが分かります。
            さらに、今回は5枚のランクが相異なる場合を除外しているので、
            それら ${\choose{13}{5}}＝1,287 通りを差し引くと、
            最終的に4,888通りが残ることになります。
          }

          +p{
            よって、理論的には4,888要素のテーブルを用意すれば、
            そのテーブルを引くことで役判定が行えることになります。
            問題はそのテーブルをどのように引くかですが、ここに\dfn-ja-en{完全ハッシュ関数}
            {Perfect hash function}を用いることを考えたのがPaul Senzeeというプログラマーです。
            完全ハッシュ関数とは、定義域が定まっているときにそれらの入力に対して単射であるような
            （つまり衝突が無い）ハッシュ関数のことで、Paul Senzeeは具体的に以下のような
            マジカルな実装を与えました:

            \d-code(```
              unsigned find_fast(unsigned u) {
                u += 0xe91aaa35;
                u ^= u >> 16;
                u += u << 8;
                u ^= u >> 4;
                unsigned a = (u + (u << 2)) >> 19;
                unsigned b = (u >> 8) & 0x1ff;
                return a ^ hash_adjust[b];
              }
            ```);
          }

          +p{
            ここで、`hash_adjust` は要素数512のマジカルな配列ですが、この関数を用いると
            前述した4,888通りの積を13ビットの一意な整数に変換することができます。
            よって、8,192要素の配列 `hash_values` を前計算することで、
            フラッシュ/ストレート/ハイカードのいずれでもない場合の処理は
            次のように記述できるようになりました。

            \d-code(```
              return hash_values[find_fast(
                (c1 & 0x3f) * (c2 & 0x3f) * (c3 & 0x3f) * (c4 & 0x3f) * (c5 & 0x3f)
              )];
            ```);
          }

          +p{
            ここまでに用意したテーブルの容量は48KB程度と、これまでに見てきたテーブルとは
            桁違いに容量を削減できており、これならキャッシュヒット率も問題ありません。
            7枚のカードからなるハンドを評価するには、\ref-subsection(`evaluator-naive`); に示した
            最もナイーブな実装と同じように ${\choose{7}{5}} 通りの5枚組を
            評価しなければなりませんが、ランダムアクセス速度（1億ハンド）は10.2秒と、
            \ref-subsection(`evaluator-naive`); の実装と比べると5倍程度高速になっています。
            7枚のカードを直接評価する \ref-subsection(`evaluator-naive-7`); の実装と比較してしまうと
            やはり遅いですが、7枚のうちどの5枚が用いられたかを復元する必要がある場合などは、
            こちらを使用した方が簡潔に処理できるかもしれません。
          }
        >

        +subsection?:(`evaluator-fastest`){これまでの考察を活かした実装} <
          +listing{
            * \dfn{シーケンシャル速度}（1.33億ハンド）: 0.16秒（8.19億評価/秒）
            * \dfn{ランダムアクセス速度}（1億ハンド）: \dfn{0.41秒（2.41億評価/秒）}
            * \dfn{メモリ使用量}: 145KB
          }

          +p{
            さて、ここまで前置きが長くなってしまいましたが、これまでの考察を活かして
            オレオレ最強爆速評価器を作ることを考えていきましょう。
          }

          +p{
            \ref-subsection(`evaluator-cactus-kev`); の Cactus Kev による実装は、
            5枚のカードからなるハンドにしか直接適用できませんでしたが、
            以下のような重要なテクニックを与えてくれました:
          }

          +listing{
            * 52枚のカードを0～51の整数ではなく特殊なフォーマットで表現する
            * フラッシュとそれ以外に処理を分割することで、テーブルサイズを大幅に削減する
            * 完全ハッシュ関数の導入
          }

          +p{
            本節では、これらのテクニックを引き続き用いながら、
            7枚のカードからなるハンドを直接評価する方法を考えていきます。
            まずは、7枚のカードの組が与えられたときに、
            フラッシュかどうかをどのように高速に判定するかを考えていきましょう。
            \ref-subsection(`evaluator-cactus-kev`); ではどのように判定していたかというと、
            各カードにスートを表す4ビットのビットフラグを持たせて、
            それらのビット論理積を取って判定をしていました。
            ハンドが7枚のカードで構成される場合では、7枚のうちの5枚が
            同じスートなら良いわけですから、全く同じ戦略を取ることはできません。
          }

          +p{
            そこで、今度は各スートの出現回数をカウンターを用いて記録することにしましょう。
            具体的には、各スートの出現回数は最大で7回ですから、8進数を用いて記録してあげれば
            良さそうです。例えば、「`0o4102`」はクラブが4枚、ダイヤモンドが1枚、ハートが0枚、
            スペードが2枚現れたことを示すといったようにです。
            このようにフォーマットを定めれば、フラッシュかどうかの判定は「5」以上の桁が存在するか
            どうかという問題に変換することができます。
          }

          +p{
            ただ、「5」以上の桁が存在するかどうかという判定を実際に行おうとすると、
            愚直に処理を書き下すしかなく、あまり高速には判定が行えません。
            そこで、8進数と言わず16進数を使うことにし、各桁に「3」だけ下駄を履かせることを考えます。
            つまり、これまで「`0o4102`」だった表現は、16進数に変換した上で各桁に「3」が足されて、
            「`0x7436`」に変換されることになります。
            このように表現すると何が嬉しいかというと、
            フラッシュかどうかの判定は「8」以上の桁が存在するかどうかという問題となり、
            ビットフラグ「`0x8888`」とビット論理積を取るだけで判定が行えるようになっているのです。
            ビット演算に不慣れな方には理解しづらいかもしれませんが、
            その場合は実際に手を動かしてみると理解できるようになるかもしれません
            （それでも良く分からない場合はそういうものだとして受け入れましょう）。
          }

          +p{
            それでは、続いてランクに関する表現を考えていきましょう。
            \ref-subsection(`evaluator-cactus-kev`); では、ランクの組み合わせを
            素数の積で表現していましたが、カードが7枚となるとその最大値は

            \eqn(${
              41^4 \times 37^3 = 143,133,271,933
            });

            となってしまい、この後に完全ハッシュ関数を適用するとはいえ、
            値がちょっと大きくなりすぎてしまいます。
            そこで、ランクの組み合わせをある基底の「積」ではなく
            「和」で表現することを考えてみましょう。
            最も明快な方法は、スートの出現回数を16進数で表現したように、
            ランクの出現回数も5進数で管理するというものです
            （同じランクのカードは最大でも4枚しか出現しないため、5進数で一意な表現が可能です）。
            つまり、基底として ${\{5^0,\ 5^1,\ \cdots,\ 5^{12}\}} を採用した場合に対応しており、
            カード7枚の組が与えられたときの最大値は

            \eqn(${
              5^{12} \times 4 + 5^{11} \times 3 = 1,123,046,875
            });

            となります。
            この時点ですでに素数の積による表現よりも最大値を小さくできていますが、
            さらに最適化された基底として、OMPEval \footnote{https://github.com/zekyll/OMPEval}
            というライブラリでは `{0x2000, 0x8001, 0x11000, 0x3a000, 0x91000, 0x176005, `
            `0x366000, 0x41a013, 0x47802e, 0x479068, 0x48c0e4, 0x48f211, 0x494493}` という
            非自明な基底が用いられています。
            この基底を用いた場合、カード7枚の組が与えられたときの最大値は
            `0x494493` × 4 + `0x48f211` × 3 = 33,548,415
            となり、表現に必要なビット数を25ビットにまで落とし込めています
            \footnote{表現に必要なビット数を削減するのみなら、23ビットにまで落とし込んだ
            基底を自前でも生成できましたが、後述の完全ハッシュ関数を構築する段になると
            こちらの基底の方が優れた結果となります。}。
            最適な基底の生成方法については筆者自身よく理解できていないのですが、
            ともあれ今回はこの基底を流用することにしましょう。
          }

          +p{
            ランクの組み合わせに関する表現が定まったので、今度は続いてこの表現に適用する
            完全ハッシュ関数を自前で定義していきましょう。
            カード7枚を用いたランクの組み合わせは49,205通り存在するため
            （${\choose{13 + 7 - 1}{7}}＝50,388 で上から抑えられることはすぐに分かります）、
            完全ハッシュ関数の値域は 0 ～ 49,204 に収まるのが理想的と言えます。
          }

          +p{
            ここからは、Single-displacement 法 \footnote{A. V. Aho and J. D. Ullman.
            \dfn{Principles of Compiler Design.} Addison-Wesley. 1977.}
            と呼ばれる手法に基づくハッシュ関数を構築することを考えていきます。
            Single-displacement 法では、次に示すような非常に単純なプログラムで
            ハッシュ値を計算します:

            \d-code(```
              hash_key = offset[input_value / t] + (input_value % t);
            ```);

            ここで、`offset` はマジカルなテーブルでこれから構築を目指す対象、${t} は
            ハッシュ関数の挙動を定めるパラメータですが、これだけでは何のこっちゃという
            感じだと思いますので、ここからは定義域を48未満の素数、また ${t = 8} として
            具体的に構築の例を見ていこうと思います。
          }

          +p{
            ${t = 8} ですので、あり得る入力を長さ8の行に分割して次のような表を得ます:

            \d-code(```
              .. ..  2  3 ..  5 ..  7
              .. .. .. 11 .. 13 .. ..
              .. 17 .. 19 .. .. .. 23
              .. .. .. .. .. 29 .. 31
              .. .. .. .. .. 37 .. ..
              .. 41 .. 43 .. .. .. 47
            ```);

            このハッシュ関数の構築において、応用上優れたパフォーマンスを発揮することが知られている
            First-fit-decreasing 法 \footnote{R. E. Tarjan and A. C. C. Yao.
            \dfn{Storing a Sparse Table.} Communications of the ACM, 22(11):606-611. 1979.}
            では、次にこれらの行を要素数が多い順に並び替えます:

            \d-code(```
              .. ..  2  3 ..  5 ..  7
              .. 17 .. 19 .. .. .. 23
              .. 41 .. 43 .. .. .. 47
              .. .. .. 11 .. 13 .. ..
              .. .. .. .. .. 29 .. 31
              .. .. .. .. .. 37 .. ..
            ```);

            最後に、各列で衝突が発生しないように、上の行から順に可能な限り小さい値でシフトします:

            \d-code(```
              shift(-2) .. .. |  2  3 ..  5 ..  7
              shift(+1)       |    .. 17 .. 19 .. .. .. 23
              shift(+6)       |                   .. 41 .. 43 .. .. .. 47
              shift(+7)       |                      .. .. .. 11 .. 13 .. ..
              shift(+9)       |                            .. .. .. .. .. 29 .. 31
              shift(+1)       |    .. .. .. .. .. 37 .. ..
              ----------------+---------------------------------------------------
                        .. .. |  2  3 17  5 19  7 37 41 23 43 11 .. 13 47 29 .. 31
            ```);
          }

          +p{
            このシフト量が先ほどマジカルなテーブルと言った `offset` に対応していて、
            今回の場合は並び替えた行を元に戻して `offset[] = { -2, 7, 1, 9, 1, 6 };` と定義すると、
            48未満の素数を定義域とした場合に 0 ～ 16 を値域とする完全ハッシュ関数を
            構築することができました。
          }

          +p{
            それでは定義域をランクの組み合わせを表現する値に差し替えて、
            同様に完全ハッシュ関数を構築することを試みてみましょう。
            手元の実装では、${t = 2^{12}} としたときに、First-fit-decreasing 法によって
            値域が 0 ～ 49,599 となる完全ハッシュ関数を構築することができました。
          }

          +p{
            さて、ここまで準備できればいよいよ実装に取り掛かることができます。
            まずは、ランクの基底となる定数を定義しましょう:

            \d-code(```
              const uint32_t rank_bases[13] = {
                0x002000, 0x008001, 0x011000, 0x03a000, 0x091000, 0x176005, 0x366000,
                0x41a013, 0x47802e, 0x479068, 0x48c0e4, 0x48f211, 0x494493,
              };
            ```);

            続いて、ハンドのデータを表現する構造体を作ります。
            SIMD命令による高速化を可能にするため、構造体は共用体の中に定義することにします:

            \d-code(```
              union HandData {
                struct {
                  uint32_t rank_key;
                  uint32_t suit_key;
                  uint64_t bit_flag;
                } s;
                __m128i simd_reg;
              };
            ```);

            ここで、`simd_reg` は構造体を128ビットレジスタとしても扱えるようにするための
            メンバ変数です。
            `rank_key` では先ほど定義したランクの基底の和を管理し、`suit_key` の
            上位16ビットではスートの出現回数を管理し、`bit_flag` では出現したカードの
            ビットセットを64ビット整数として管理することにします
            （64ビット整数を16ビットごとに分割し、下位からクラブ、ダイヤモンド、ハート、スペードの
            2～Aに対応させます）。
          }

          +p{
            このように `HandData` 共用体を定義したら、各カードを次のように定数として定義できます:

            \d-code(```
              const HandData cards[52] = {
                /* 2c */ {{ rank_bases[0], 0x1000'0000, 0x0000'0000'0000'0001 }},
                /* 2d */ {{ rank_bases[0], 0x0100'0000, 0x0000'0000'0001'0000 }},
                /* 2h */ {{ rank_bases[0], 0x0010'0000, 0x0000'0001'0000'0000 }},
                /* 2s */ {{ rank_bases[0], 0x0001'0000, 0x0001'0000'0000'0000 }},
                /* 3c */ {{ rank_bases[1], 0x1000'0000, 0x0000'0000'0000'0002 }},
                (中略),
                /* As */ {{ rank_bases[12], 0x0001'0000, 0x1000'0000'0000'0000 }},
              };
            ```);

            さらに、実装の肝となる `Hand` 構造体も続けて定義していきましょう:

            \d-code(```
              class Hand {
              public:
                Hand() : data{{ 0, 0x3333'0000, 0 }} {}
                Hand(__m128i simd_reg) : data{.simd_reg = simd_reg} {}
                Hand add_card(int card) const;
                uint16_t evaluate() const;

              private:
                HandData data;
              };
            ```);

            デフォルトコンストラクタでは、`suit_key` をカウンタの初期値が3となるよう
            `0x3333'0000` で初期化し、他のメンバは `0` で初期化しています。
            また、`simd_reg` を引数とするコンストラクタも定義しておきます。
          }

          +p{
            残るは `Hand::add_card()` と `Hand::evaluate()` の実装のみです。
            `Hand::add_card()` については簡単で、自分自身に `cards[card]` を足し合わせたものを
            返せば良く、SIMD命令を用いるように実装すると次のようになります:

            \d-code(```
              Hand Hand::add_card(int card) const {
                return Hand{_mm_add_epi64(data.simd_reg, cards[card].simd_reg)};
              }
            ```);
          }

          +p{
            最後に、`Hand::evaluate()` の実装を先に与えてしまうと次のようになります:

            \d-code(```
              uint16_t Hand::evaluate() const {
                uint32_t is_flush = data.s.suit_key & 0x8888'0000;
                if (is_flush) {
                  uint16_t flush_key = data.s.bit_flag >> (4 * leading_zeros(is_flush));
                  return lookup_flush[flush_key];
                } else {
                  uint32_t hash_key = offset[data.s.rank_key >> 12] + data.s.rank_key;
                  return lookup[hash_key];
                }
              }
            ```);

            ここで、`leading_zeros()` は2進数表記での leading zero の個数を返す関数です
            （gcc/clang における `__builtin_clz()` と同様）。
            以下簡単に `Hand::evaluate()` の実装を解説すると、2行目における `is_flush` の定義では、
            先述したように `suit_key` に「8」以上の桁が存在するかどうかを
            チェックした結果が代入されています。
            もしフラッシュの場合は、`bit_flag` を適切にシフトして、フラッシュとなっている
            スートで出現したランクのビットセットを取得し（4行目）、そのビットセットで
            フラッシュ用のテーブルを引いています（5行目）。
            フラッシュでなかった場合は、Single-displacement 法によるハッシュ値を計算し（7行目）、
            そのハッシュ値でテーブルを引いています（8行目）。
          }

          +p{
            `offset`、`lookup`、`lookup_flush` はいずれも前計算を必要とするテーブルです。
            まず `offset` については、 `rank_key` の最大値が33,548,415、
            また ${t = 2^{12}} としたことを思い出すと、その要素数は
            ${\floor{33,548,415\ /\ 2^{12}} + 1}＝8,191個となります。
            また、完全ハッシュ関数の値域は 0 ～ 49,599 でしたので、`lookup` の要素数は49,600個です。
            最後に `lookup_flush` については、ビットセットの最大値は `0x1fc0 = 8,128` ですので、
            要素数は8,129個となります。
            これらのデータサイズは合計しても145KBに収まっており、
            例えばWebアプリ等に組み込むことも可能でしょう。
          }

          +p{
            記事の最後に紹介する実装だけあって、本節はここまでで6ページ超に及んでいますが、
            苦労した甲斐はちゃんとあり、シーケンシャル速度は0.16秒と
            \ref-subsection(`evaluator-twoplustwo`); の Two Plus Two evaluator に次いで速く、
            ランダムアクセス速度は最速の0.41秒を記録しました。
            特に、ランダムアクセス速度は \ref-subsection(`evaluator-naive-7`); の
            ナイーブな実装が高い壁として立ちはだかっていましたので、
            ここまで工夫することでようやく打破できたという喜びを一緒に感じていただければ幸いです。
          }
        >
      >

      +section{まとめ} <
        +p{
          テキサスホールデムの役判定を題材に、プログラムの高速化にまつわる
          さまざまなテクニックを紹介してみました。
          ニッチな題材なだけあって、ビット演算のテクニックやソートの高速化、
          完全ハッシュ関数についてなど、紹介したテクニックもニッチなものが多かったかもしれませんが、
          数学力、アルゴリズム力、実装力、アーキテクチャへの理解などさまざまな分野にまたがった力が
          求められる内容でもあったのではないかと思います。
        }

        +p{
          今回ベンチマークに使用したプログラムは `https://github.com/b-inary/yabai-vol6-src` に
          公開していますので、実装の細部を確認したい方はそちらを参照ください。
          また、5～7枚のカードからなるハンドに対応したRust製ライブラリ
          `https://github.com/b-inary/holdem-hand-evaluator` も公開していますので、
          興味のある方はそちらもぜひ参照ください
          （こちらには \ref-subsection(`evaluator-fastest`); で用いられているテーブルの
          生成スクリプトも含まれています）。
        }

        +p{
          ゲーム自体も奥が深く、数学的にもプログラマ的にも興味深いテキサスホールデム、
          みなさんもぜひプレイしてみてください！
        }
      >
    >
  >

end
