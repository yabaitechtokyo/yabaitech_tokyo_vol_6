@require: itemize
@require: code
@require: base/image

@require: class-yabaitech/yabaitech

module Binary : sig

  val article : block-text

end = struct

  let-inline \dfn-ja-en ja en = {\dfn{#ja; (#en;)}}

  let article = '<
    +chapter(|
      bibliography = [];
      title = {テキサスホールデムの役判定に見る高速化テクニック (仮)};
      title-for-toc = Option.none;
      subtitle = Option.none;
      author = {ばいなり};
    |)
    <
      +section{はじめに} <
        +p{
          はじめまして、 yabaitech.tokyo の新メンバーのばいなりです。
          yabaitech.tokyo のメンバーの一部でテキサスホールデムポーカーが流行っており、
          一緒にポーカーで遊んでいたらこちらに加入させられてしまいました。
          せっかくなのでポーカーに関する技術記事を書こうということで、
          今回はテキサスホールデムの役判定を爆速で行う話についてでも書かせてもらえればと思います。
        }

        +p{
          所詮はポーカーの役判定ごとき、もともと愚直に書いてもマイクロ秒単位で処理できるため、
          もともと高速じゃないか、そんなものを高速化して何が面白いのかと思われるかもしれませんが、
          次章で説明するようにテキサスホールデムポーカーでは使えるカードが
          明らかになっていない段階でアクションを起こす必要があり、
          その時点での勝率を計算しようとすると大量にあり得るハンドの役判定を行わねばならず、
          この処理の高速化が要求されるわけです。
          最終的には処理時間が\dfn{約1ナノ秒}のプログラムまで紹介しますので、
          楽しみに読み進めていただけれると幸いです。
        }
      >

      +section{テキサスホールデムのルール} <
        +p{
          \dfn-ja-en{テキサスホールデム}{Texas hold'em} は、数あるポーカーの変種の中でも
          世界的に見て最もポピュラーなものと言えるゲームです。
          日本ではまだ馴染みの薄い感じもありますが、世界的には数多くのプレイヤーがおり、
          最も権威ある世界大会ではなんと10,000,000ドル (!) もの優勝賞金が懸けられるほどです。
          この章では、テキサスホールデムとは何ぞやという方に向けて、そのルールを簡単に説明します
          （テキサスホールデムを既に知っている方は読み飛ばしていただいても構いません）。
        }

        +subsection?:(`list-of-poker-hands`){役の一覧} <
          +p{
            テキサスホールデムにおける役は5枚のカードの組み合わせで決まり、
            強い順に以下の9つがあります。
            さまざまなポーカーの変種で共通なため、馴染みのある方も多いでしょう。
          }

          +enumerate{
            * \dfn-ja-en{ストレートフラッシュ}{Straight flush}:
              フラッシュとストレートの複合役。すべての役の中で最も強い。
              例: AsKsQsJsTs (TODO: スペードなどのマークをここで使いたい)
            * \dfn-ja-en{フォーカード}{Four of a kind}:
              同じランクのカードを4枚集めた役。
              例: 6s6h6d6cJd
            * \dfn-ja-en{フルハウス}{Full house}:
              同じランクのカード3枚と、別の同じランクのカード2枚で構成される役。
              例: KhKdKc3h3c
            * \dfn-ja-en{フラッシュ}{Flush}:
              同じスートのカードを5枚集めた役。
              例: QhTh7h5h4h
            * \dfn-ja-en{ストレート}{Straight}:
              数字が連続した5枚のカードで構成される役。
              Aは14または1として扱うことができる。
              A、K、2の3枚を含むものはストレートとは見なされない。
              例: JhTc9c8h7s
            * \dfn-ja-en{スリーカード}{Three of a kind}:
              同じランクのカードを3枚集めた役。
              例: 5s5d5cAhJc
            * \dfn-ja-en{ツーペア}{Two pair}:
              同じランクのカード2枚の組を2組集めた役。
              例: 8s8c3s3dQd
            * \dfn-ja-en{ワンペア}{One pair}:
              同じランクのカードを2枚集めた役。
              例: 7d7c9s4s2d
            * \dfn-ja-en{ハイカード}{High card}:
              上記のいずれにも当てはまらないもの。いわゆる“ブタ”。
              例: AcJs8d4c2h
          }

          +p{
            役が同じ場合は、カードのランク（数字）をもとにタイブレークがなされます
            （Aが最も強く、2が最も弱い\; ストレートでAを1として扱った場合のみAが最も弱い）。
            カードのスート（柄）はハンドの強さに影響しません。
            このようにハンドの強さを定義した場合、
            ハンドは7462種の同値類に分類されることが知られています。
          }
        >

        +subsection{テキサスホールデムの進行} <
          +p{
            テキサスホールデムでは、\dfn-ja-en{ホールカード}{Hole cards}と呼ばれる
            各プレイヤーに2枚ずつ配られるカードと、\dfn-ja-en{コミュニティカード}{Community cards}
            と呼ばれるプレイヤー全員が使用できる5枚の共通のカードの計7枚の中から、
            最も強い5枚の組み合わせを用いてハンドの強さを競います。
            よくあるクローズドポーカーとは異なり、配られた手札を交換することはできません。
            最終的に手札を公開してハンドの強さを競うことになった場合
            （これを\dfn-ja-en{ショーダウン}{Showdown}と呼ぶ）、
            より強いハンドを持っていたプレイヤーが
            それまでに賭けられてきた\dfn-ja-en{ポット}{Pot}を総取りします。
          }

          +p{
            ただし、実際の進行ではショーダウンが行われることはそれほどありません。
            というのも、他のプレイヤーを全員“降ろす”ことができれば、
            その時点でポットは残った1人のプレイヤーのものとなるためです。
            ベッティングラウンドでは、賭け金の合意が取れるまで各プレイヤーは定められた順序で
            以下のいずれかのアクションを取る必要があります:
          }

          +listing{
            * \dfn-ja-en{ベット}{Bet} / \dfn-ja-en{レイズ}{Raise}:
              現在の賭け金からさらに賭け金を上乗せするアクションです。
              賭け金がゼロの状態から行うアクションをベット、
              既にベットされている状態から行うアクションをレイズと言います。
            * \dfn-ja-en{チェック}{Check} / \dfn-ja-en{コール}{Call}:
              現在の賭け金に同意し、同額を支払ってプレイを継続するアクションです。
              追加の賭け金が必要無い状態で行うアクションをチェック、
              賭け金を追加で支払う必要のある状態で行うアクションをコールと言います。
            * \dfn-ja-en{フォールド}{Fold}:
              現在の賭け金を支払わず、手札を捨てて勝負から降りるアクションです。
              フォールドを行うと、それ以降のベッティングラウンドにも参加できず、
              ポットを獲得する権利を完全に失います。
          }

          +p{
            テキサスホールデムでは、ショーダウンまでに4回のベッティングラウンドを行います:
          }

          +listing{
            * \dfn-ja-en{プリフロップ}{Pre-flop}:
              2枚のホールカードが配られた直後に行われるラウンドです。
              コミュニティカードは1枚も公開されません。
              プリフロップでは、\dfn-ja-en{スモールブラインド}{Small blind}と
              \dfn-ja-en{ビッグブラインド}{Big blind}と呼ばれる2人のプレイヤーは
              定められた額のベットを強制的に行わなければなりません。
            * \dfn-ja-en{フロップ}{Flop}:
              コミュニティカードが3枚公開された状態で行われるラウンドです。
            * \dfn-ja-en{ターン}{Turn}:
              4枚目のコミュニティカードが公開された状態で行われるラウンドです。
            * \dfn-ja-en{リバー}{River}:
              5枚目のコミュニティカードが公開され、すべてのコミュニティカードが
              明らかになった状態で行われるラウンドです。
          }

          +p{
            特にプリフロップの段階では、最終的に使用できる7枚のカードのうち2枚しか
            明らかになっていません。この時点での勝率の計算などを厳密に行おうとすると、
            大量にあり得るハンドの役判定が必要になるという冒頭の主張に繋がるわけです。
          }
        >
      >

      +section{レギュレーション} <
        +p{
          さて、以上に説明したテキサスホールデムのルールを踏まえて、
          作りたいプログラムの要件を定義していきましょう。
          今回の目標は「7枚のカードの組が与えられたときの役の判定」を行うプログラムであって、
          なるべく高速なものを作ることです。
          もう少し厳密に書くと、次の要件を満たすようななるべく高速な関数の実装を目指します。
        }

        +listing{
          * 7枚のカードで構成されるハンドを入力として受け取って非負整数を返す関数であって、
            \ref-subsection(`list-of-poker-hands`); に示したようにハンドの強さを定義したとき、
            より強いハンドが入力として与えられた場合はより大きい整数を返し、
            強さが同じハンドが入力として与えられた場合は同じ整数を返すようなもの
            （特に、役が同じであっても多くの場合はタイブレークによる強弱が存在することに注意する）。
        }

        +p{
          なお、各カードは0～51の整数で表現されているものとし、0～3が2c2d2h2s、4～7が3c3d3h3s、
          ${\cdots}、48～51がAcAdAhAsに対応しているものとします。
        }

        +p{
          今回は勝率計算などに用いるサブルーチンとしての役判定を想定しているため、
          プログラムの高速化のために次のような機能は含めなくてよいものとします:
        }

        +listing{
          * ハンドが7枚未満の場合の役判定を行う機能。
          * 7枚のカードのうちどの5枚が用いられたかを示す機能。
          * 入力のバリデーションチェック。すなわち、入力長が7であり、入力の各要素が
            0～51の整数であって相異なることを仮定する。
        }

        +p{
          プログラムは以下の3点によって評価されます:
        }

        +listing{
          * \dfn{シーケンシャル速度}:
            52 choose 7 (TODO: 数式にしたい)（＝133,784,560）通りの7枚のカードの組み合わせについて
            辞書順にハンドの評価を行い、掛かった時間を計測する。
            この測定では、ハンドを表現する何らかのデータ構造にカードを追加する操作は
            最内ループの外で行っても良いものとする。
            すなわち、以下のようなプログラムが認められる:

            \d-code(```
              Hand hand = Hand();
              for (int card1 = 0; card1 < 46; ++card1) {
                // add_card()の複雑さに関わらず、この操作を以降のループ中に含めなくてよい
                Hand hand1 = hand.add_card(card1);  // handにcard1を追加した結果を返す
                for (int card2 = card1 + 1; card2 < 47; ++card2) {
                  Hand hand2 = hand1.add_card(card2);
                  // 3枚目以降のカードの処理...
                }
              }
            ```);

          * \dfn{ランダムアクセス速度}:
            1億通りのランダムなハンドについて評価を行い、掛かった時間を計測する。
            この測定では、0～51の整数からなる要素数7のランダムな配列のみが予め用意される。
            なお、配列の要素はソートされているとは限らない。
            ハンドを表現する何らかのデータ構造にカードを追加する操作が必要な場合は
            毎回ゼロから行う必要があり、その時間も計測結果に反映される。

          * \dfn{メモリ使用量}:
            これから紹介するプログラムには、予め前計算したテーブルを用いるものが含まれるため、
            そういった静的なテーブルの大きさを示す（実行時のメモリ使用量を計測したものではない）。
            静的なテーブルを用いない場合は「極小」と表記する。
        }

        +p{
          プログラムの記述言語にはC++17を採用します。
          また、実行時間の計測には筆者のデスクトップマシン（Ryzen 7 3700X CPU）を用います。
        }

        +p{
          それでは、次章でさまざまな実装について見ていきましょう！
        }
      >

      +section{さまざまな実装} <
        +subsection?:(`evaluator-naive`){ナイーブな実装} <
          +listing{
            * \dfn{シーケンシャル速度}（1.33億ハンド）: 64.8秒（206万評価/秒）
            * \dfn{ランダムアクセス速度} （1億ハンド）: 52.4秒（191万評価/秒）
            * \dfn{メモリ使用量}: 極小
          }

          +p{
            何はともあれ、まずはベースラインとなるナイーブな実装について見ていきましょう。
            7枚のカードから5枚を選ぶ21通りの選び方を予め定数として用意しておき、
            その組み合わせをすべて試して最も強かった結果を返すというのが
            ナイーブな実装の大枠になるかと思います。
          }

          +p{
            5枚のカードからなるハンドの評価を行う関数 `evaluate_hand_naive_5()`については
            後ほど見ていくことにして、プログラムを記述していくと次のようになるでしょう:

            \d-code(```
              // 7 choose 5の組み合わせを予め定数として持っておく
              const int comb75[21][5] = {
                { 0, 1, 2, 3, 4 }, { 0, 1, 2, 3, 5 }, (中略), { 2, 3, 4, 5, 6 }
              };

              // 7枚のカードからなるハンドの強さを評価する
              int evaluate_hand_naive(const vector<int> &hand) {
                int best = 0;
                vector<int> subhand(5);
                for (int i = 0; i < 21; ++i) {
                  for (int j = 0; j < 5; ++j) {
                    subhand[j] = hand[comb75[i][j]];
                  }
                  best = max(best, evaluate_hand_naive_5(subhand));
                }
                return best;
              }
            ```);
          }

          +p{
            それでは、関数`int evaluate_hand_naive_5(const vector<int> &hand);`を続いて
            定義していきましょう。ナイーブとは言えども、ビット演算を利用した効率的な実装を
            目指すこととし、まずは出現したスートとランクを管理するビットセットと、
            各ランクの出現回数を管理する変数を準備します。

            \d-code(```
              int suitset = 0;
              int rankset = 0;
              int rankcount[13] = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };
              for (int card : hand) {
                int suit = card % 4;
                int rank = card / 4;
                suitset |= 1 << suit;
                rankset |= 1 << rank;
                ++rankcount[rank];
              }
            ```);

            さらに、出現回数からランクのビットセットを逆引きできる変数も準備します。

            \d-code(```
              int rankset_of_count[5] = { 0, 0, 0, 0, 0 };
              for (int rank = 0; rank < 13; ++rank) {
                rankset_of_count[rankcount[rank]] |= 1 << rank;
              }
            ```);

            以上の変数が用意できれば、フラッシュとストレートの判定は以下のように行えます。

            \d-code(```
              bool is_flush = count_ones(suitset) == 1;
              int is_straight = rankset & (rankset << 1) & (rankset << 2)
                              & (rankset << 3) & (rankset << 4);
              if (rankset == 0b1'0000'0000'1111) is_straight = 1 << 3;
            ```);

            ここで、`count_ones()`は2進数表記でのビットの立っている数を返す関数とします
            （gcc/clangにおける`__builtin_popcount()`と同様）。
            フラッシュの判定は明らかですが、ストレートの判定については解説が必要かもしれません。
            ストレートが成立している場合、ランクのビットセットは5桁連続でビットが立っている
            ことになります（5432Aの場合を除く）。このとき、ビットを0～4桁ズラしたもの同士で
            ビット論理積を取るとその結果は非ゼロとなります。

            \d-code(```
                0000000111110 (x)
              & 0000001111100 (x << 1)
              & 0000011111000 (x << 2)
              & 0000111110000 (x << 3)
              & 0001111100000 (x << 4)
              ------------------------
                0000000100000
            ```);

            逆に、ストレートが成立していない場合は、このビット論理積はゼロとなります。
            よって、唯一の例外である5432Aのストレートについて最後にケアしてあげれば、
            変数`is_straight`は非ストレートの場合はゼロ、またストレートの場合は非ゼロでかつ
            最もランクの大きいカードの情報が入っている状態となります。
          }

          +p{
            ここまで準備ができれば、あとはナイーブに役判定を行っていくのみです。
            ここで返り値のフォーマットについて考える必要がありますが、
            上位4ビットに役の情報を、下位26ビットにタイブレークに関する情報を埋め込んだ
            30ビットの整数を用いることにしましょう。

            \d-code(```
              if (is_flush && is_straight) {
                // straight flush
                return (8 << 26) | is_straight;
              } else if (rankset_of_count[4]) {
                // four of a kind
                return (7 << 26) | (rankset_of_count[4] << 13) | rankset_of_count[1];
              } else if (rankset_of_count[3] && rankset_of_count[2]) {
                // full house
                return (6 << 26) | (rankset_of_count[3] << 13) | rankset_of_count[2];
              } else if (is_flush) {
                // flush
                return (5 << 26) | rankset;
              } else if (is_straight) {
                // straight
                return (4 << 26) | is_straight;
              } else if (rankset_of_count[3]) {
                // three of a kind
                return (3 << 26) | (rankset_of_count[3] << 13) | rankset_of_count[1];
              } else if (rankset_of_count[2]) {
                // two pair or one pair
                int num_pairs = count_ones(rankset_of_count[2]);
                return (num_pairs << 26) | (rankset_of_count[2] << 13) | rankset_of_count[1];
              } else {
                // high card
                return (0 << 26) | rankset;
              }
            ```);
          }

          +p{
            以上がナイーブな実装についてでしたが、これだけで予想外に3ページ半も
            費やしてしまいました。タイブレークまで正確に考慮した実装を簡潔に記述するのは
            案外簡単ではないのではということで丁寧に解説してみましたが、いかがでしたでしょうか。
          }
        >

        +subsection{7枚のカードを直接評価する実装（ナイーブ）} <
          +listing{
            * \dfn{シーケンシャル速度}（1.33億ハンド）: 4.32秒（3100万評価/秒）
            * \dfn{ランダムアクセス速度} （1億ハンド）: 4.19秒（2390万評価/秒）
            * \dfn{メモリ使用量}: 極小
          }

          +p{
            \ref-subsection(`evaluator-naive`); で紹介したナイーブな実装は 7 choose 5 通りの
            カードの選び方をすべて試すものでしたが、7枚のカードが与えられたときにそれらを
            直接評価する戦略も考えられます。
            例えば、KcTd8c4c4h4s3hというハンドが与えられたとき、人間は 7 choose 5 通りのカードの
            選び方を考えなくとも、まず4のスリーカードを認識し、残ったカードのうちランクの高い
            KcとTdを加えた4c4h4sKcTdが最終的な5枚組になることを瞬時に把握できるでしょう。
          }

          +p{
            このような戦略に基づく実装を正確に書き下すのは、5枚のハンドを評価する実装と比べてさらに
            注意力を要しますが、丁寧に考察をしていけばそれなりに簡潔に記述することが可能です。
            まずは、ユーティリティ関数として上位`n`ビットを保持する関数を定義しましょう:

            \d-code(```
              int keep_n_msb(int x, int n) {
                int result = 0;
                for (int i = 0; i < n; ++i) {
                  int m = msb(x);
                  x ^= m;
                  result |= m;
                }
                return result;
              }
            ```);

            ここで、 `msb(x)` は入力 `x` の最上位ビットのみが立った値を返す関数とします
            （gcc/clangでは `int` 型に対しては `1 << (__builtin_clz(x) ^ 31)` として定義できます）。
            このような関数を用意できると、先ほどの例のようなスリーカードの処理は次のように
            書き下すことができます:

            \d-code(```
              // スリーカードより強い役ではないことが確認できているとする
              if (rankset_of_count[3]) {
                // three of a kind
                int remaining = keep_n_msb(rankset_of_count[1], 2);
                return (3 << 26) | (rankset_of_count[3] << 13) | remaining;
              }
            ```);

            本節では実装のすべての紹介は行いませんが、この戦略に基づく実装を実際に書いてみようと
            いう場合は、ストレートとフラッシュが両方成立しているからといってストレートフラッシュとは
            限らない点（ストレートフラッシュは同じスート内でストレートを完成させる必要がある）、
            3枚組が2つある場合の処理（フルハウス）、2枚組が3つある場合の処理（ツーペア）などに
            気をつけてみてください。
          }

          +p{
            筆者の実装では、\ref-subsection(`evaluator-naive`); の実装と比べて
            12～15倍の高速化を実現することができました。
            どの5枚が最終的に用いられたかの情報を復元する処理は自明には書けなくなって
            しまいましたが、それと引き換えにこれだけの高速化が施せれば十分でしょう。
          }

          +p{
            このような記事を書いておいて言うのもなんですが、ポーカーの役判定が必要となるような
            場面のほとんどは、\ref-subsection(`evaluator-naive`); と本節に示したような
            ナイーブな処理で正直間に合うようにも思います。
            ここからさまざまなテクニックを用いて処理を高速化していくわけですが、
            最終的に得られるプログラムは本節のものと比べて25倍速いという程度に留まります。
            この25倍を引き出す過程が面白いと感じたからこそこのような記事を
            書いているわけではありますが、25倍遅い程度で済むなら明快な処理を好むという方も
            少なくないのではないでしょうか。
            また、ナイーブな実装は高速な実装の動作をテストする際にも役に立ちますので、
            ナイーブなものが悪いということでは決してない点は留意していただければと思います。
          }
        >
      >
    >
  >

end
